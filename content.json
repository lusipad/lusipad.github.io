{"pages":[{"title":"缘起","text":"这是lusipad的个人博客.记录下自己生活和学习中的一些事儿. 很多时候明明如鲠在喉, 但是却又无法开口,是了, 那是因为想的不够多, 辩得不够明,所以似是而非, 似懂非懂.源于此, 起个博客, 记录一二. — 记于2018.11","link":"/about/index.html"},{"title":"categories","text":"","link":"/categories/index.html"},{"title":"tags","text":"","link":"/tags/index.html"}],"posts":[{"title":"加油武汉","text":"加油武汉!","link":"/加油武汉.html"},{"title":"<不测的秘密-精准测试之路>读后感","text":"123主观评分: 8.5阅读时间: 2h(粗读)一句话点评: 通过分析二进制,区分分支覆盖,并且辅以推荐系统,来达到精确测试. 发现测试那边人手一本&lt;不测的秘密–精准测试之路&gt;, 借阅了以后大概的粗略看了下. 目前我们测试也发现了这样一个问题, 因为测试和开发是分离的, 所以开发说只修改了一行代码, 测试怎么确保你所修改的影响范围呢? 大家都知道墨菲定律, 所以这个时候看似最靠谱的策略就是全部重测… 本书的作者就是通过一个个小故事, 来讲述怎么样去精准的测试, 只测试受影响的. 具体的做法就是通过分析二进制文件, 根据调用链来确定对测试用例的影响, 后续辅以推荐系统, 做到自动推荐受影响的测试范围. 但是腾讯的书的通病, 书里提到的东西… 都是不开源的… 上次看&lt;腾讯游戏开发&gt;就很头痛了, 讲了一堆我们做了个巴拉巴拉的东西, 思路是怎么样怎么样的.. 结果一看, 不开源的, 都是内部用的, 照着来做一个, 不知道要踩多少坑. 这个也是, 虽然没有开动, 但是肉眼可见的, 又是一个看上去很美的项目… 暂时先这样, 等后续考虑TDD的时候再想想这个是不是可以集成进去.","link":"/不测的秘密-精准测试之路-读后感.html"},{"title":"<代码精进之路--从码农到工匠>读后感","text":"123主观评分: 9.5阅读时间: 6(粗读)一句话点评: [toc] 原本以为这本只是一本跟风之作, 因为&lt;程序员修炼之道–从小工到专家&gt;实在是太有名了, 导致后续不少书都有类似从xx到xx之类的副标题, 而且质量又良莠不齐, 特别容易引人浮躁. 但是这本书不同, 这本书可以说是今年至今为止让我最爱不释手的一本了, 忍不住想要好好精读一遍. 为什么这本书让我爱不释手?因为这本书解决了好几个我心中的疑惑, 但是又不知如何去描述的问题, 等看到了相关章节, 真的有一种aha moment的感觉, 个中滋味, 如人饮水, 冷暖自知. “愿天下没有烂代码”, 这本书以此为切入点, 首先描述了一些编程技巧和方法论, 然后从更高层次的思想指导, 来统领方法论和技巧, 特别是对于技术Leader的职责给出了切实有效的建议, 最后则是结合了一些实践, 包括他们自研的COLA架构和落地. 全书之中, 对我最有价值的部分莫过于技术Leader这个章节了. 因为我本身也是突然变成了这样一个定位, 挺迷茫自己究竟要做什么, 而作者对于技术Leader和Manager的分析, 让人恍然大悟, 作者还辅以OKR, CodeReivew, 技术规划等等一系列切实有效的技术Leader工作, 受益匪浅, 待开年后心里就有谱了. 并且这本书也可以作为一个技术目录使用, 因为很多点其实作者只是浅尝辄止, 并未有特别深入去说明, 完全可以在后续进行补充. 命名有意义的命名变量名应该是名词, 能够正确地描述业务, 有表达力. 函数命名要具体, 空乏的命名没有意义. 函数的命名要体现做什么, 而不是怎么做. 类分成两大类: 试题类和辅助类. 实体类承载了核心业务数据和核心业务逻辑, 其命名要充分体现业务语义, 辅助类是辅助实体类一起完成业务逻辑的, 其命名要能够通过后缀来体现功能. 包代表了一组有关系的类的集合, 起到分类组合和命名空间的作用. 规范发现共通抽象和机制, 可以在很大程度上帮助我们理解复杂系统. 日志规范Error表示不能自己恢复的错误, 需要立即被关注和解决. Warn, 对于可预知的业务问题, 最好不要用Error输出日志, 以免污染报警系统. 例如: 参数校验不通过, 没有访问权限等业务异常, 就不应该用Error输出. Info用于记录系统的基本运行过程和运行状态. 异常规范异常处理很多应用系统因为没有同意的异常处理规范, 增加了认为的复杂性: (1) 代码中导出充斥着异常捕获的try/catch, 搞乱了代码结构, 把错误处理和正常流程混为一谈, 严重影响了代码的可读性. (2) 异常处理不统一, 有的场景对外直接抛出异常, 有的场景对外返回错误码, 这种不一致性让服务的调用方摸不着头脑, 增加了服务的使用成本和沟通成本. 针对以上问题, 建议在业务系统中设定两个异常, 分别是业务异常和系统异常. 设计原则SOLID. Single Responsibility Principle. (SRP) 单一职责原则. Open Close Principle. (OCP) 开闭原则, Liskov Substitution Principle. (LSP) 里式替换原则. Interface Segregation Principle. (ISP) 接口隔离原则. Dependency Inversion Principle. (DIP) 依赖倒置原则. Don’t Repeat Yourself. (DRY) You Ain’t Gonna Need It.(YAGNI) Rule Of Three. (第三次出现时, 才开始抽象化) Keep It Simple and Stuipid. (KISS) Principle of least astonishment. (POLA) 最小惊奇原则. 设计模式模式不是框架, 也不是过程. 模式不是简单的”问题的解决方案”, 必须是典型问题的解决方案, 是可以让学习者举一反三的, 是理论和实践之间的中介环节. 模式具有一般性, 简单性, 重复性, 结构性, 稳定性和可操作性等特征. 技术Leader的修养技术氛围一个技术团队, 不管大小, 如果没有”技术味道”, 那么技术Leader负有很大的责任. 代码好坏味道周会的主持人需要给大家分享3个代码好味道和3个代码坏味道代码, 这些代码既可以是来自我们工作中的代码, 也可以是来自开源软件的源码. 技术分享分享是倒逼我们区学习和总结的有效手段 CR周报各种Code Review的方式都很好, 但是有一个共同的缺点, 就是很难将过程透明化. CR周报就是要把CR的结果透明化, 通过周报的形式展现团队在一周中的CR成果, 包括团队成员的CR评论排名, 代码分支的质量情况, 以及CR中的典型案例. 这种透明化非常有价值, 既可以帮助技术Leader了解代码质量的概况, 也能极大地调用团队成员进行CR的积极性. 读书会书的范围可以放宽一点, 读书的形式可以是同读一本书, 也可以是拆书. 读书会的举办频率可以灵活一些. 目标管理技术规划技术规划更多的是从团队视角去看接下来要做的事情, 而目标管理师要把规划要做的事情进行拆解, 和个人目标对齐. 做好技术规划是非常重要的事情, 一个团队有没有价值, 最终还是要通过做出来的事情来体现. 当前问题主要看团队中现在有什么迫切, 紧急的问题要解决, 有什么坑要去填. 技术领域在常规领域中, 根据业务情况和团队情况选择一些领域和命题(比如稳定, 性能, 效率等), 并在这些命题和方向中根据优先级做判断. 业务领域充分了解业务, 关注业务, 要分析业务数据和发展趋势, 和业务同事充分交流, 总结和抽象出业务的发展对技术会提出什么诉求, 需要技术做什么布局和建设以应对业务发展的需求. 团队特色对比团队内外技术的异同, 最终圈定一个差异化区域. Leader和Manager的区别Manager是管理事务, 是控制和权威; 而Leader是领导人心, 是引领和激发. 我们不需要这么多高高在上, 指点江山的技术Manager, 而是需要更多能够真正深入系统里面, 深入代码细节, 给团队带来改变的技术Leader.","link":"/代码精进之路-从码农到工匠-读后感.html"},{"title":"学习路线","text":"临近年关了, 最近的工作重心也落到了聊聊绩效和未来一年的规划, 能够感受到大家的对未来的憧憬, 也有很多迷茫和彷徨, 但是总体来说氛围还是比较向上的. 因为最近Review了不少代码, 有相当一部分是我自己不熟悉的功能, 需要花费一些精力去了解背后的逻辑, 所以愈发觉得自己还是太菜了, 想做的想学的很多, 但是如何去做好它, 可能真的需要花费一番功夫. 怎样学习怎么样去学习? 大多数人脑中的第一反应是看书. 看书能够提供系统性的知识, 对于个人学习还是非常有帮助的. 但是看书又往往是效率很低的, 网上有这样的说法, 虽然不能全信, 但还是有一点道理的: 只是听讲，在一个月之后就剩下5%； 只是阅读，在一个月之后就剩下10%； 只是视听，在一个月之后就剩下20%； 经常看演示，在一个月之后就剩下30%； 经常讨论，在一个月之后就剩下50%； 经常实践，在一个月之后就剩下75%； 把学到的知识教授给他人，在一个月之后能剩下90%！ 教授这事儿相对而言会麻烦点, 那么我们可以选择实践! 学习什么聊了一段时间后, 我发现OKR(目标管理)非常适合学习这个场景. 目标管理的核心是什么? 具有挑战性的积极目标 + 量化的关键结果 + 持续的反馈. 所以我就问了新人, 你的目标是什么? “学好C#”. 那我们的目标就是学好C#, 那你怎么去衡量自己学好了C#呢? 是看完了&lt;精通C#&gt;, 看完了&lt;C#本质论&gt;还是看完了Channel9上的C#视频? 都不是, 这些只是过程, 哪怕你完成了, 也并不能证明你学好了C#. 这个时候你就应该去找关键结果, 能够用来量化你学好C#的证明. 比如说, 熟练掌握了C#的语言特性XML特性, 能够使用XML开发一个RSS订阅软件. 而且, 还要加上时间, 不要过短, 不宜过长. 两个月, 足矣. 当你能把所有的关键结果都讲清楚了, 想清楚了, 你的路子就不会歪了. 可惜我C#不行, 所以讲不出太多. 语言学习其实语言的学习, 我个人倒是觉得最简单. 为什么? 因为目标明确. 任何一种语言, 不管你是python还是汇编, 总之离不开这样的几个过程: 掌握语言特性. 这里基本上就是语法啊, 特性啊, 常用库之类, 看本身复杂度, 短则几天, 长则数月. 熟练应用. 这个阶段可能会持续很长, 并且每个人的环境, 压力不同, 所以成长速度不一定, 在这个阶段, 会开始逐渐深入, 当然更多人可能会因为没有持续的输入或者输出, 出现了”瓶颈”. 设计. 这个阶段就是俗称的”造轮子”, 自己写库, 自己深挖编译器… 不一而足. 就以我熟悉的C++而言, 第一阶段, 掌握语言特性, 了解编程范式, &lt;C++ Primer&gt;学习语法和STL, 配合一定量的练习, 你就已经入门, 可以干活了. 第二阶段, 一方面是随着代码的越写越多, 你需要总结经验和继续深入, 这个时候你可能就要开始看, , &lt;深入探索C++对象模型&gt;, &lt;STL源码剖析&gt;, &lt;STL标准库&gt;… 另一方面则是广度, 你开始接触更多设计的, 架构的方法和思想, 所以&lt;设计模式 可复用面向对象软件的基础&gt;, &lt;代码整洁之道&gt;, &lt;重构 改善既有代码的质量&gt;, &lt;领域驱动设计&gt;之类的悄悄爬上了你的书桌. 第三阶段, 你开始想要去了解更多的细节, 挖掘更多深层次的内容. 看源码, 自己写库, 并且N多C++程序员最爱的工作造轮子就会发生在此时. 其实还有很多想法, 但是总觉得太过碎片化, 可能以后留着更新吧","link":"/学习路线.html"},{"title":"没有硝烟的战场--索罗斯 VS 香港","text":"最近刷B站有点多, 主要是为了学习, 然后关注了一波涨姿势的UP主. 其中巫师财经是我收藏夹里已经躺了老久了, lKs之前有一期视频, 讲述视频拍摄成本中, 就拿党妹, 巫师财经等人举了例子, 其中对于巫师财经不乏溢美之词, 在他们去拍摄百万奢侈品进当铺那一集中, 富婆十音也直接一句不介绍了, 有兴趣的请去看巫师财经节目云云. 然后今天看了后, 真香! UP主思路明确, 切入点出色, 将索罗斯做空这十余年的大事娓娓道来, 巧妙的降维到幼儿园, 保证了整个叙述的完整性. 另一篇保时捷大众的大战, 虽然已经过去了十数年, 但是详细的资料依然令人动容. 这个视频则是让人对于金融从业者有了更多的了解. 其他的做了一些明星和奢侈品之类相关的, 有点蹭热度试探粉丝的感觉, 而且据说作者从中行离开后也开始自己创业了, 希望以后不要变成了恰饭视频…","link":"/没有硝烟的战场-索罗斯-VS-香港.html"},{"title":"<程序员的三门课>读书笔记","text":"123主观评分: 7花费时间: 8h(粗读)一句点评: 这是一个IT人实践的记录, 作者想要讲得广, 不知是限于篇幅还是自身能力, 最后变成了水. [toc] 作为一个爱囤书的仓鼠党, 每月惯例就是看看有啥子新书可以买买买, 在新书里看到了这本&lt;程序员的三门课–技术精讲 架构设计 管理探秘&gt;, 书的内容分为三大部分: 介绍程序员的技能成才路径 架构思维模式, 架构设计过程 做技术管理的的诀窍 看着就是干货满满, 包罗万象的样子, 虽说按照一般经验来说, 国内作者这种样样通的书往往会很水 但是还是欣然购入喜加一. 本书主要是于泽君的自己的一些理解和感悟, 和自己成长过程中的新路历程及他的一些总结, 同时也邀请了其他4位作者一起合作的书, 可以看出来, 不管是行书的结构还是字里行间, 还是以他为主, 其他人为辅助, 他的技术栈是以Java为主, 在架构方面, 也以领域模型和分层介绍得最为详细, 而管理相关的就相对没有那么系统性的方法论, 而是更多零碎的个人经验. 史海峰的推荐序我个人甚是喜欢, 他讲述的是世界上需要什么样的程序员, 他认为好的程序员应该是工型人才, 一横: 具备完成完整应用的能力, 包括运维, 成为熟手; 一纵:在某些领域足够深入, 成为高手; 一横: 达到更高水平后, 兼容多个领域, 成为驱动着和领导者. 程序员的技能与成长如何学习一门新语言在学习一门语言时, 重点应该关注三个点: 基本表达形式, 组合的方法, 抽象的方法.这三点对应的其实就是三个点: 基础知识, 应用和设计. 动态语言, 静态语言, 强类型语言, 弱类型语言, 编译型语言, 解释型语言, 都要浅尝辄止.只有看多了, 你才能更加领略每种语言的其中三味, 所以我打算后面先学Python, 然后LISP, 这里先立个Flag. 我记得C语言之父在写的时候就提到了关于学习的一些话题, 在完成了史诗般巨作的&lt;C++ Primer&gt;之后, 他发现这本砖头书实在是不适合入门, 所以他回头头来写了, 在这本书, 他不再按照面面俱到的细数所有C++特性, 而是将C++的几种编程范式, 通过精心准备的由浅入深的例子来呈现. 虽然我了解到这本书的时候已经过了入门这个槛了, 但是看看还是收益良多的. 因为语言不仅仅是语法, 在刚开始学习的时候, 总觉得像&lt;精通Visual C++&gt;这种书, 简单又明了, 所有概念都分门别类, 一条条的特别清楚. 直到自己用了多年, 才感受到语言自有魅力和逻辑, 而不仅仅是搬砖那么简单. 其他的一些经验, 比如带着问题去学习, 勤加练习, 教学相长之类的, 都算是老生常谈了. 测试驱动开发作者似乎非常推崇测试驱动开发, 他提到了自己曾经做了一件现在看起来不靠谱的事情, 就是把一个模块的代码测试覆盖率达到了80%, 但是测试覆盖率低的原因往往是: 团队成员没有写测试的习惯, 没有意识到其重要性, 不想写 代码难于测试, 不会写 赶进度, 没有时间写 相比于提高覆盖率, 解决这些问题更加重要, 代码覆盖率的提升, 从本质上来说并不是解决这些问题的良药, 糟糕的代码哪怕你提高了测试覆盖率, 在面对新需求时, 可能又是一堆无效且累赘的代码. 这件事我感受颇为深刻, 因为同样的事情我也做过, 然后半途而废了. 为啥? 因为我发现单元测试虽然能对代码质量有所帮助, 但是更大的问题其实在于糟糕的设计, 抱歉真的是非常糟糕, 而且很多还是自己挖的坑, 可能真的是需要重构这把钥匙才有希望解决这些问题, 如今的自己还是没有真正的想好, 后面应该怎么样做.我们不仅违反了测试驱动设计的步骤, 甚至还违反了同步编写开发代码和测试代码的思路, 可能过年的时候, 自己好好实践下, TDD是不是真的是灵丹妙药了. 然后作者这里就开始水了N页, 去给出了一个TDD的操作例子, 没办法, Java的框架巴拉巴拉的代码一写上, 动辄就是一页的代码, 这个我还是觉得&lt;C++程序设计与实践: 测试驱动开发&gt;这本书写得更详尽和深入一点. 静态代码分析作者分享了一些Java的静态代码分析工具, 对于一个CLike语言的使用者, 又是几大章跳过的内容, 目前自用的CppCheck和Visual Studio的代码分析工具还是挺好用的. 代码审查这一章对我而言感觉非常重要, 因为自己最近也在做代码审查工作, 但是效果不好(虽然总有一种正在渐入佳境的错觉), 个人思来想去外加问大佬后的最终结论是: 自己太菜了.为什么审核不出结果? 是因为自己太菜了, 全程都没法跟上别人的思路, 那除了简单的看看逻辑有没有错误, 谈何从设计从更高的层次去发现问题? 关于代码审查, 从一个评审人的角度, 我个人的观点是这样的: 将代码放在整个环境去中看, 并不是一个片段, 除非你很熟悉, 不然光Diff不是一个优秀的审查方法 代码审查是一个持续性的工作, 快速的反馈, 不懂就问 代码审查不仅是个审查的机会, 更是个学习的机会 而作者似乎对工具比较推崇, 认为工具和检查清单在整个代码审查过程中都很重要, 这点我只能说认同一半吧, 工具只是提高效率, 但是更多的功夫是在评审之外的. 工具化对于统一的工具平台, 需要考虑不同工具的层次, 使其能够尽量的复用; 对于差异较大的, 则分别建设. 我发现作者似乎对于工具和自动化特别的推崇, 可能是我对Java的理解还停留在以前使用Eclipse开发的古老年代, 在那个年代Java中有大量大量的简单而又机械的工作, C++程序员老是在造轮子…. 自动化自动化测试作为有效的提效手段, 是每个技术团队都在追求的目标. 核心问题有两个: 分层和稳定. 分层: 各种复杂功能需要不同的粒度来保证, 单元测试, 组件测试, 接口测试, 灰度测试等需要结合使用. 稳定: 持续集成的基础, 自动化屏蔽了逻辑的细节, 将前人的测试经验代码化了, 所以引入了一个测试成熟度: 一方面评价代码覆盖, 另一方面评价CI的通过率. 文档又是一个痛点. 传统的文档管理方式, 总是让人迷失在文档的海洋里… 作者的几个观点虽然比较零碎, 但也有一定的道理: 研发过程的关键文档: 需求和系统分析 Core文档, 必须定期维护 用例即文档 API接口生成 程序员的工具箱Perl之父Larry Wall提到: 程序员的三个美德是懒惰, 懒惰和懒惰. 作者在这里提到了许多能够提升程序员工作效率的软硬件, 还有在线工具. 加速成长与学习积极主动, 选择合适的平台, 别怕犯错, 注意细节, 时间管理, 打破边界, 带着思考写代码. 其实我认为最最重要的两点就是时间管理和带着思考写代码. 时间管理这个问题有点老生常谈了, 但是作者关于会议的一些经验, 还是很有帮助的: 参加必要的会议, 尽量避免参加不必要的会议. 尽量不要让不紧要的讨论打断正在做的事情 可以提前约定时间, 不需要再专注于代码的时间段打扰自己 然后就是重要紧急四象限, 优先做重要的事情! 带着思考去写代码也很重要, 写代码也分几个层次: 第一个层次, 让代码写得不一样, 规范性, 可读性, 可扩展性… 第二个层次, 考虑业务问题和技术问题的匹配, 可以从写业务代码中理解需求, 做好分析和设计. 第三个层次, 总结相关方法体系, 成为业务及技术的双料专家. 学会学习管理好自己的目标, 利用好碎片化时间, 一次只做一件事. 两个著名的学习理论德雷福斯模型一种衡量人们的工作方法和能力, 反省并提高专业技能的层级模型: 新手: 需要指令清单, 很少的经验, 通过模仿和观察来学习 高级新手: 不需要全局思维, 可以独立尝试任务, 但扔难以解决问题 胜任者: 能够解决问题 精通者: 能够自我纠正, 需要全局思维, 将围绕某种技术, 寻找并想了解更大的概念框架 专家: 专家凭借直觉工作, 有丰富的经验, 可以在前挡的情境中选取和应用自己的经验, 需要保持实践来维持水平 刻意锻炼理论专家水平是可以训练出来的. 业务分析与设计用特定的方式或方法, 把复杂的需求拆解成更简单并且容易理解的对象, 并找出这些对象间的关系 领域驱动设计(DDD)领域驱动设计提出了领域模型的概念, 抛弃了将分析与设计分开的做法, 使用统一的模型来满足分析与设计的需求. 领域设计 = 边界 + 设计; 有界上下文 = 用户 + 领域 + 功能. 那么领域驱动设计就是一种定义边界, 并且在设计阶段融合了原形的设计方法? 领域驱动设计的三个核心原则: 把项目的重点放在核心域和域逻辑上 把复杂的设计放在有界域模型上 和领域专家不断协作晚上应用模型来解决特定领域的问题 领域驱动设计就是先将领域中涉及的数据,流程,商业规规则等都弄明白, 然后以面向对象的观点为其建立一个领域模型, 再选用合适的软件技术实现这个模型. 问题域就是数据, 流程和规则; 问题解决域就是用软件去实现这个模型. 后续需要补充一些相关资料来学习, 作者这里写得太乱了, 看着吃力 架构修炼分解高内聚, 低耦合; 层次性; 正交原则(分层后都是独立的); 抽象; 稳定; 复用 复用可扩展性, 灵活性, 可插入性.一个复杂性较好的系统, 就是一个易维护的系统. 为了可维护性, 我们有一些原则: 开闭原则 抽象化是开闭原则的关键, 可以为系统定义一个稳定的抽象层, 将不同的实现行为移至具体的实现层. LSP里氏代换原则 将基类替换成子类对象不会有任何错误, 这个就是实现开闭原则的重要方式之一. DIP依赖倒置 依赖于抽象而不是实现 ISP接口隔离原则 每个接口应该承担一种相对独立的角色,不干不该干的事情. CARP组合聚合复用原则 尽量使用组合或聚合关系,少用继承. 使用继承复用会破坏系统的封装性. LoD迪米特法则 尽量减少对象直接的通信 模式根据业务需求来选择最合适的技术, 而不是用主流和最先进的技术去反推业务. 作者介绍了一些模式, 但都比较简单, 我觉得后面可以专门写一篇模式相关的文章来说这个问题, 这里仅做简单的说明, 而且我觉得这里虽然都是模式,但是领域不一样, 放在一起写挺奇怪的… 分层 每层只能与位于其下方的层发生耦合, 四层/五层/六边形架构都是领域驱动比较经典的架构. C/S 客户端/服务器模式 主从 管道-过滤器 一种松耦合的设计模式, 各过滤器只需要实现单一功能, 降低了依赖和复杂度 代理 在结构和系统中对组件进行解耦, 组件之间都过RPC的方式进行交互, 代码组件则用于协调. P2P 事件总线 事件源, 事件监视器, 通道和事件总线. MVC 黑板 观察者模式的扩展, 包括知识源, 黑板数据和控制; 相比观察者, 多了黑板数据模式匹配. 解释器 结构化Who, What, When, Where, Why, How, How much 架构设计稳定, 解耦, 抽象, 松耦合, 容错 技术架构无状态, 可复用, 松耦合, 可治理, 基础服务(这个是适用于网络的) 架构设计的流程这里作者提到了学习元模型, 来自己设计, 后续给出的都是Web开发的一些例子, 就暂时不看了. 质量与风险PDCAPlan, Do. Check, Act 可能引起质量问题的坑业务发展, 问题域的复杂性, 系统的复杂性, 技术债, 人/流程/文档的博弈, 采用不能掌控的工具和框架, 质量意识 管理必须的技能准备, 视角转换, 学会用户思维, 建立经济视角, 成为内部商务合作, 规划团队从规划自己开始, 数据驱动 技术领导力4个维度: 提供清晰的领导力风格, 并以信任感作为基石 了解业务, 并带领团队到到高绩效 发展自己和团队成员 塑造未来 让自己成为T型人才: 离开舒适区 坚持阅读和与不同领域的人交流 创造需求, 基石应用和实践自己掌握的知识 尝试训练自己动多角度看待问题 给学习和应用设定目标和里程碑 高效管理时间: 确定在做的事情符合自己的目标 随时应用80/20法则 创造大块的时间 如何解决不服的员工 如何处理冲突 如何管理更多人员 从管理这章而言, 我最大的体会还是自己把时间和精力都花在了不重要的事情上, 导致整个团队的效率是在下降的, 后续会思考如何让我们整个团队保持一个更高的效率! 总结总得看下来, 这本书的质量其实并不高, 里面很多的内容其实是作者的经验谈, 结合了一些比较泛泛的方法论, 组织上追求全而缺乏核心主题, 所以不是很系统, 看上去就特别空, 有一种背概念的感觉. 其中的一些经验比如说团队管理和个人管理, 对我个人而言, 还是很有借鉴和帮助的, 但是技术路线就差的比较远了. TODO了解DDD领域驱动设计 使用TDD开发一个小项目 整理书中提到的模式和应用场景 在团队中尝试使用OKR的方式来管理目标 使用德雷福斯模型分析团队现状, 并制定发展规划","link":"/程序员的三门课-读书笔记.html"},{"title":"lua序列化","text":"将一个表序列化成一个字符串, 逻辑很简单, 就是递归调用 + 类型判断. 12345678910111213141516171819202122232425262728293031323334353637383940-- 字符串序列化 + 缩进function serialize(param, level) local result = \"\" local space = \"\" local t = type(param) if (nil == level) then level = 0 end for i = 1, level do space = space .. \"\\t\" end if t == \"number\" then result = result .. param elseif t == \"boolean\" then result = result .. tostring(param) elseif t == \"string\" then result = result .. string.format(\"%q\", param) elseif t == \"table\" then result = result .. \"{\\n\" for k, v in pairs(param) do result = result .. space .. \"\\t\" .. \"[\" .. serialize(k) .. \"] = \" .. serialize(v, level + 1) .. \",\\n\" end local metatable = getmetatable(param) if metatable ~= nil and type(metatable.__index) == \"table\" then for k, v in pairs(metatable.__index) do result = result .. \"[\" .. serialize(k) .. \"] = \" .. serialize(metatable.__index[v], level + 1) .. \",\\n\" end end result = result .. space .. \"}\" elseif t == \"nil\" then return nil else -- @warning 不支持表中的function的序列化 end return resultend 测试12345678910111213141516tb = { a = 'a', b = \"banana\", c = { 1, 2, 3, hello = \"world\" }, d = 10, \"e\", \"f\"}print(serialize(tb)) 输出结果12345678910111213{ [1] = &quot;e&quot;, [2] = &quot;f&quot;, [&quot;b&quot;] = &quot;banana&quot;, [&quot;c&quot;] = { [1] = 1, [2] = 2, [3] = 3, [&quot;hello&quot;] = &quot;world&quot;, }, [&quot;a&quot;] = &quot;a&quot;, [&quot;d&quot;] = 10,}","link":"/lua序列化.html"},{"title":"<C++性能优化>读后感","text":"拜读了Kurt Guntheroth的Optimized C++: Proven Techniques for Heightened Performance(&lt;C++性能优化指南&gt;), 除了要吐槽下作者各种强行引用各种名人名言外, 还是受益良多的. 之前对于性能优化, 比较茫然, 最多也就能说得出一些常用的优化手段, 比如不用值传递啊, vector需要reverse啊, 各种排序算法性能啊.. 总之就是杂七杂八根据没个头绪. 最大的感受就是一点: 法有尽, 而术无穷. 现在的计算机性能不断增长, 所以即使是性能优化, 也在不断的演进. 一些比如PIMPL之类, 针对于以前编译慢的优化, 在如今, 完全可以忽略不计了.对于现在的C++性能优化, 我们应该抓住其主要矛盾: 1. 算法/逻辑 2. 硬件瓶颈. 从算法逻辑的角度, 选用更好的编译器, 更好的处理逻辑, 更好的内存结构. 从硬件的角度, 处理现在最大的瓶颈—内存, 减少内存分配复制. 现在只是简单过了一遍, 对于其中的并发优化, 内存管理器优化等还是需要进一步学习. 打算后面再看下Windows/Visual Studio相关的性能分析和优化等, 重新好好做个总结.","link":"/C-性能优化-读后感.html"},{"title":"lua的capi","text":"概述由于工作中需要使用lua + C++, 所以需要学习两者之间是如何交互的(CAPI),看了一些网上的资料, 对于这方面的资料不是很详尽, 而且文章水平良莠不齐,导致阅读后常陷入知其然不知其所以然的茫然. 所以自己整理了下相关的内容, 按照自己的理解, 从头到尾梳理了一下. CAPI概述","link":"/lua的capi.html"},{"title":"lua解析xml","text":"概述由于在工作中需要使用lua解析器xml, 所以学习了下相关的内容.为了尽可能降低依赖, 所以使用纯lua写的xml解析, 避免引入其他依赖库, 徒添烦恼.然后就找到了这个开源库: 由于这个库是基于lua5.1的, 所以他提供的require相关语法,放在新版本上市不可用的, 所以稍微修改了一点, 以保证在5.1的后续版本还是可以使用.以下为修改后的: 使用方法更多思考","link":"/lua解析xml.html"},{"title":"hexo建站实录","text":"之前的小站用的wordpress, 主要也是为了写写东西记录下,但是使用wordpress之后,就开始沉迷于各种插件, 比如七牛云图床插件啊,Wordpress支持插件啊, 代码高亮插件啊… 还有从我的印象笔记摘抄笔记也特别麻烦, 因为显示的效果总不是很满意,有鉴于此, 所以决定回归markdown,只关心写作内容.目前主流的markdown建站, 也就hexo和jekyll.因为之前用hexo搭过一个githubio, 所以还是选hexo了.絮絮叨叨了这么多, 以下为建站实录: 安装hexo为文章指定标签为文章指定目录设定文章置顶文章显示”阅读更多”文章中的空格/换行安装icuras主题安装icuras修改icuras的个人信息修改icuras主题为双栏修改icuras目录的名字修改icuras的显示宽度启用搜索插件在github上建立站点在VPS上建立站点SEO通用SEO优化googlebaidu","link":"/hexo建站实录.html"},{"title":"C#学习笔记-委托","text":"什么是委托委托是C#中的一个重要的概念.委托是一个对象, 它本身含有一个或者多个方法, 可以认为是一个类型安全的, 面向对象的C++函数指针.是对于C++中函数指针的一种”升级”, 因为指针除了地址本身外, 并没有办法携带其他描述的信息.而委托可以 一个简单的C++函数指针例子123456789101112131415161718192021#include &lt;iostream&gt;int(*Calc)(int x, int y);int Add(int x, int y){ return x + y;}int Sub(int x, int y){ return x - y;}int main(){ Calc = Add; std::cout &lt;&lt; Calc(1, 2) &lt;&lt; std::endl; Calc = Sub; std::cout &lt;&lt; Calc(1, 2) &lt;&lt; std::endl;} 输出结果123-1 这里就是把函数的指针作为一个参数传递, 这样就可以通过一种方法去处理多个具有相同返回值和参数类型. C#的函数指针例子123456789101112131415161718192021222324252627namespace SampleDelegate{ delegate int Calc(int x, int y); class MainClass { static int Add(int x, int y) { return x + y; } static int Sub(int x, int y) { return x - y; } public static void Main(string[] args) { Calc calc; calc = Add; Console.WriteLine(calc(1, 2)); calc = Sub; Console.WriteLine(calc(1, 2)); } }} 输出结果123-1 这个结果是C++函数指针的效果是相同的. 委托的声明和创建委托也是一种类, 所以也是一个引用. [delegate] [返回值] [对象名] [签名]delegate void Calc(int x); 使用new来创建calc = new calc(Add); 快捷语法创建calc = Add; 委托的组合委托实际是一个引用, 所以委托的组合其实是指向了一个新的委托.123calc1 = Add;calc2 = Sub;calc1 = calc1 + calc2; 也可以使用+=和-=123calc += Add;calc += Sub;calc -= Add; 委托的使用带参数/返回值的委托如果委托有返回值, 并且方法列表不止一个方法, 那么返回值就用最后一个. 如果委托有引用参数, 在调用过程中, 会将参数的新值传给下一个方法. 泛型委托除了使用固定的参数, 委托也支持使用泛型12345678910111213141516171819202122232425262728namespace SampleDelegate{ delegate T Calc&lt;T&gt;(T x, T y); class MainClass { static int Add(int x, int y) { return x + y; } static double Sub(double x, double y) { return x - y; } public static void Main(string[] args) { Calc&lt;int&gt; calc; calc = Add; Console.WriteLine(calc(1, 2)); Calc&lt;double&gt; calc2; calc2 = Sub; Console.WriteLine(cal2(1, 2)); } }} Action&lt;&gt;委托Action就是系统定义的, 返回值为void的委托. Func&lt;&gt;委托Func就是系统定义的, 带有返回值的委托, 其中最后一个是返回值. 实际上, .Net的许多重要API都大量的使用Action和Func 委托的常见使用场景回调使用注意事项委托的代码实现本文参考&lt;C#入门视频&gt;&lt;图解C#教程&gt;&lt;精通C#(第6版)&gt;","link":"/C-学习笔记-委托.html"},{"title":"C#学习笔记","text":"背景描述记录自己学习C#的学习记录 阅读和学习视频 刘铁锰 &lt;C#语言入门详解&gt; 读书笔记学习笔记 委托","link":"/CSharp学习笔记.html"}],"tags":[{"name":"加密算法, 性能","slug":"加密算法-性能","link":"/tags/加密算法-性能/"},{"name":"TDD","slug":"TDD","link":"/tags/TDD/"},{"name":"测试驱动开发","slug":"测试驱动开发","link":"/tags/测试驱动开发/"},{"name":"C++","slug":"C","link":"/tags/C/"},{"name":"性能优化","slug":"性能优化","link":"/tags/性能优化/"},{"name":"阅读","slug":"阅读","link":"/tags/阅读/"},{"name":"C#","slug":"C","link":"/tags/C/"},{"name":"委托","slug":"委托","link":"/tags/委托/"},{"name":"笔记","slug":"笔记","link":"/tags/笔记/"},{"name":"hexo","slug":"hexo","link":"/tags/hexo/"},{"name":"建站","slug":"建站","link":"/tags/建站/"},{"name":"icuras","slug":"icuras","link":"/tags/icuras/"},{"name":"lua","slug":"lua","link":"/tags/lua/"},{"name":"序列化","slug":"序列化","link":"/tags/序列化/"},{"name":"capi","slug":"capi","link":"/tags/capi/"},{"name":"xml","slug":"xml","link":"/tags/xml/"},{"name":"测试","slug":"测试","link":"/tags/测试/"},{"name":"精准测试","slug":"精准测试","link":"/tags/精准测试/"},{"name":"读书笔记","slug":"读书笔记","link":"/tags/读书笔记/"},{"name":"学习路线","slug":"学习路线","link":"/tags/学习路线/"},{"name":"财经","slug":"财经","link":"/tags/财经/"},{"name":"视频","slug":"视频","link":"/tags/视频/"},{"name":"方法论","slug":"方法论","link":"/tags/方法论/"},{"name":"代码质量","slug":"代码质量","link":"/tags/代码质量/"},{"name":"程序员","slug":"程序员","link":"/tags/程序员/"}],"categories":[{"name":"TDD","slug":"TDD","link":"/categories/TDD/"},{"name":"读书笔记","slug":"读书笔记","link":"/categories/读书笔记/"},{"name":"C#","slug":"C","link":"/categories/C/"},{"name":"网站","slug":"网站","link":"/categories/网站/"},{"name":"lua","slug":"lua","link":"/categories/lua/"},{"name":"杂记","slug":"杂记","link":"/categories/杂记/"},{"name":"财经","slug":"财经","link":"/categories/财经/"}]}