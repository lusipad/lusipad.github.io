{"pages":[{"title":"缘起","text":"这是lusipad的个人博客.记录下自己生活和学习中的一些事儿. 很多时候明明如鲠在喉, 但是却又无法开口,是了, 那是因为想的不够多, 辩得不够明,所以似是而非, 似懂非懂.源于此, 起个博客, 记录一二. — 记于2018.11","link":"/about/index.html"},{"title":"categories","text":"","link":"/categories/index.html"},{"title":"tags","text":"","link":"/tags/index.html"}],"posts":[{"title":"C#学习笔记","text":"背景描述记录自己学习C#的学习记录 阅读和学习视频 刘铁锰 &lt;C#语言入门详解&gt; 读书笔记 C#图解教程(第4版) 精通C#(第6版) CLR via C# C#6.0本质论 C#经典实例 学习笔记 委托 事件 Lambda表达式 反射 练习 dll版本比较工具","link":"/CSharp学习笔记.html"},{"title":"lua加密","text":"lua加密编译, opcode, loadbuffer加密, 文本加密…","link":"/lua加密.html"},{"title":"lua序列化","text":"将一个表序列化成一个字符串, 逻辑很简单, 就是递归调用 + 类型判断. 12345678910111213141516171819202122232425262728293031323334353637383940-- 字符串序列化 + 缩进function serialize(param, level) local result = \"\" local space = \"\" local t = type(param) if (nil == level) then level = 0 end for i = 1, level do space = space .. \"\\t\" end if t == \"number\" then result = result .. param elseif t == \"boolean\" then result = result .. tostring(param) elseif t == \"string\" then result = result .. string.format(\"%q\", param) elseif t == \"table\" then result = result .. \"{\\n\" for k, v in pairs(param) do result = result .. space .. \"\\t\" .. \"[\" .. serialize(k) .. \"] = \" .. serialize(v, level + 1) .. \",\\n\" end local metatable = getmetatable(param) if metatable ~= nil and type(metatable.__index) == \"table\" then for k, v in pairs(metatable.__index) do result = result .. \"[\" .. serialize(k) .. \"] = \" .. serialize(metatable.__index[v], level + 1) .. \",\\n\" end end result = result .. space .. \"}\" elseif t == \"nil\" then return nil else -- @warning 不支持表中的function的序列化 end return resultend 测试12345678910111213141516tb = { a = 'a', b = \"banana\", c = { 1, 2, 3, hello = \"world\" }, d = 10, \"e\", \"f\"}print(serialize(tb)) 输出结果12345678910111213{ [1] = &quot;e&quot;, [2] = &quot;f&quot;, [&quot;b&quot;] = &quot;banana&quot;, [&quot;c&quot;] = { [1] = 1, [2] = 2, [3] = 3, [&quot;hello&quot;] = &quot;world&quot;, }, [&quot;a&quot;] = &quot;a&quot;, [&quot;d&quot;] = 10,}","link":"/lua序列化.html"},{"title":"<C++性能优化>读后感","text":"拜读了Kurt Guntheroth的Optimized C++: Proven Techniques for Heightened Performance(&lt;C++性能优化指南&gt;), 除了要吐槽下作者各种强行引用各种名人名言外, 还是受益良多的. 之前对于性能优化, 比较茫然, 最多也就能说得出一些常用的优化手段, 比如不用值传递啊, vector需要reverse啊, 各种排序算法性能啊.. 总之就是杂七杂八根据没个头绪. 最大的感受就是一点: 法有尽, 而术无穷. 现在的计算机性能不断增长, 所以即使是性能优化, 也在不断的演进. 一些比如PIMPL之类, 针对于以前编译慢的优化, 在如今, 完全可以忽略不计了.对于现在的C++性能优化, 我们应该抓住其主要矛盾: 1. 算法/逻辑 2. 硬件瓶颈. 从算法逻辑的角度, 选用更好的编译器, 更好的处理逻辑, 更好的内存结构. 从硬件的角度, 处理现在最大的瓶颈—内存, 减少内存分配复制. 现在只是简单过了一遍, 对于其中的并发优化, 内存管理器优化等还是需要进一步学习. 打算后面再看下Windows/Visual Studio相关的性能分析和优化等, 重新好好做个总结.","link":"/C-性能优化-读后感.html"},{"title":"lua的capi","text":"概述由于工作中需要使用lua + C++, 所以需要学习两者之间是如何交互的(CAPI),看了一些网上的资料, 对于这方面的资料不是很详尽, 而且文章水平良莠不齐,导致阅读后常陷入知其然不知其所以然的茫然. 所以自己整理了下相关的内容, 按照自己的理解, 从头到尾梳理了一下. CAPI概述","link":"/lua的capi.html"},{"title":"lua解析xml","text":"概述由于在工作中需要使用lua解析器xml, 所以学习了下相关的内容.为了尽可能降低依赖, 所以使用纯lua写的xml解析, 避免引入其他依赖库, 徒添烦恼.然后就找到了这个开源库: 由于这个库是基于lua5.1的, 所以他提供的require相关语法,放在新版本上市不可用的, 所以稍微修改了一点, 以保证在5.1的后续版本还是可以使用.以下为修改后的: 使用方法更多思考","link":"/lua解析xml.html"},{"title":"dll版本比较工具","text":"","link":"/dll版本比较工具.html"},{"title":"C#经典实例","text":"","link":"/C-经典实例.html"},{"title":"C#6.0本质论","text":"","link":"/C-6-0本质论.html"},{"title":"CLR via C#","text":"","link":"/CLR-via-C.html"},{"title":"精通C#(第6版)","text":"","link":"/精通C-第6版.html"},{"title":"hexo建站实录","text":"之前的小站用的wordpress, 主要也是为了写写东西记录下,但是使用wordpress之后,就开始沉迷于各种插件, 比如七牛云图床插件啊,Wordpress支持插件啊, 代码高亮插件啊… 还有从我的印象笔记摘抄笔记也特别麻烦, 因为显示的效果总不是很满意,有鉴于此, 所以决定回归markdown,只关心写作内容.目前主流的markdown建站, 也就hexo和jekyll.因为之前用hexo搭过一个githubio, 所以还是选hexo了.絮絮叨叨了这么多, 以下为建站实录: 安装hexo为文章指定标签为文章指定目录设定文章置顶文章显示”阅读更多”文章中的空格/换行安装icuras主题安装icuras修改icuras的个人信息修改icuras主题为双栏修改icuras目录的名字修改icuras的显示宽度启用搜索插件在github上建立站点在VPS上建立站点SEO通用SEO优化googlebaidu","link":"/hexo建站实录.html"},{"title":"C#学习笔记-事件","text":"","link":"/C-学习笔记-事件.html"},{"title":"C#学习笔记-委托","text":"什么是委托委托是C#中的一个重要的概念.委托是一个对象, 它本身含有一个或者多个方法, 可以认为是一个类型安全的, 面向对象的C++函数指针.是对于C++中函数指针的一种”升级”, 因为指针除了地址本身外, 并没有办法携带其他描述的信息.而委托可以 一个简单的C++函数指针例子123456789101112131415161718192021#include &lt;iostream&gt;int(*Calc)(int x, int y);int Add(int x, int y){ return x + y;}int Sub(int x, int y){ return x - y;}int main(){ Calc = Add; std::cout &lt;&lt; Calc(1, 2) &lt;&lt; std::endl; Calc = Sub; std::cout &lt;&lt; Calc(1, 2) &lt;&lt; std::endl;} 输出结果123-1 这里就是把函数的指针作为一个参数传递, 这样就可以通过一种方法去处理多个具有相同返回值和参数类型. C#的函数指针例子123456789101112131415161718192021222324252627namespace SampleDelegate{ delegate int Calc(int x, int y); class MainClass { static int Add(int x, int y) { return x + y; } static int Sub(int x, int y) { return x - y; } public static void Main(string[] args) { Calc calc; calc = Add; Console.WriteLine(calc(1, 2)); calc = Sub; Console.WriteLine(calc(1, 2)); } }} 输出结果123-1 这个结果是C++函数指针的效果是相同的. 委托的声明和创建委托也是一种类, 所以也是一个引用. [delegate] [返回值] [对象名] [签名]delegate void Calc(int x); 使用new来创建calc = new calc(Add); 快捷语法创建calc = Add; 委托的组合委托实际是一个引用, 所以委托的组合其实是指向了一个新的委托.123calc1 = Add;calc2 = Sub;calc1 = calc1 + calc2; 也可以使用+=和-=123calc += Add;calc += Sub;calc -= Add; 委托的使用带参数/返回值的委托如果委托有返回值, 并且方法列表不止一个方法, 那么返回值就用最后一个. 如果委托有引用参数, 在调用过程中, 会将参数的新值传给下一个方法. 泛型委托除了使用固定的参数, 委托也支持使用泛型12345678910111213141516171819202122232425262728namespace SampleDelegate{ delegate T Calc&lt;T&gt;(T x, T y); class MainClass { static int Add(int x, int y) { return x + y; } static double Sub(double x, double y) { return x - y; } public static void Main(string[] args) { Calc&lt;int&gt; calc; calc = Add; Console.WriteLine(calc(1, 2)); Calc&lt;double&gt; calc2; calc2 = Sub; Console.WriteLine(cal2(1, 2)); } }} Action&lt;&gt;委托Action就是系统定义的, 返回值为void的委托. Func&lt;&gt;委托Func就是系统定义的, 带有返回值的委托, 其中最后一个是返回值. 实际上, .Net的许多重要API都大量的使用Action和Func 委托的常见使用场景回调使用注意事项委托的代码实现本文参考&lt;C#入门视频&gt;&lt;图解C#教程&gt;&lt;精通C#(第6版)&gt;","link":"/C-学习笔记-委托.html"},{"title":"C#学习笔记-反射","text":"","link":"/C-学习笔记-反射.html"},{"title":"C#学习笔记-Lamda表达式","text":"","link":"/C-学习笔记-Lambda表达式.html"},{"title":"C#图解教程","text":"书籍介绍","link":"/C-图解教程.html"}],"tags":[{"name":"CSharp","slug":"CSharp","link":"/tags/CSharp/"},{"name":"C#图解教程","slug":"C-图解教程","link":"/tags/C-图解教程/"},{"name":"笔记","slug":"笔记","link":"/tags/笔记/"},{"name":"Lamda","slug":"Lamda","link":"/tags/Lamda/"},{"name":"事件","slug":"事件","link":"/tags/事件/"},{"name":"委托","slug":"委托","link":"/tags/委托/"},{"name":"反射","slug":"反射","link":"/tags/反射/"},{"name":"练习","slug":"练习","link":"/tags/练习/"},{"name":"hexo","slug":"hexo","link":"/tags/hexo/"},{"name":"建站","slug":"建站","link":"/tags/建站/"},{"name":"icuras","slug":"icuras","link":"/tags/icuras/"},{"name":"C++","slug":"C","link":"/tags/C/"},{"name":"性能优化","slug":"性能优化","link":"/tags/性能优化/"},{"name":"阅读","slug":"阅读","link":"/tags/阅读/"},{"name":"lua","slug":"lua","link":"/tags/lua/"},{"name":"序列化","slug":"序列化","link":"/tags/序列化/"},{"name":"xml","slug":"xml","link":"/tags/xml/"},{"name":"capi","slug":"capi","link":"/tags/capi/"},{"name":"加密算法, 性能","slug":"加密算法-性能","link":"/tags/加密算法-性能/"}],"categories":[{"name":"CSharp","slug":"CSharp","link":"/categories/CSharp/"},{"name":"网站","slug":"网站","link":"/categories/网站/"},{"name":"C++","slug":"C","link":"/categories/C/"},{"name":"lua","slug":"lua","link":"/categories/lua/"}]}