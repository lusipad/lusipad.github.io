<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>lusipad的博客</title>
  
  <subtitle>Talk is cheap, show me the code.</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://nas.lus.red/"/>
  <updated>2020-01-22T14:20:16.750Z</updated>
  <id>http://nas.lus.red/</id>
  
  <author>
    <name>lusipad</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>&lt;不测的秘密-精准测试之路&gt;读后感</title>
    <link href="http://nas.lus.red/%E4%B8%8D%E6%B5%8B%E7%9A%84%E7%A7%98%E5%AF%86-%E7%B2%BE%E5%87%86%E6%B5%8B%E8%AF%95%E4%B9%8B%E8%B7%AF-%E8%AF%BB%E5%90%8E%E6%84%9F.html"/>
    <id>http://nas.lus.red/不测的秘密-精准测试之路-读后感.html</id>
    <published>2020-01-22T13:47:06.000Z</published>
    <updated>2020-01-22T14:20:16.750Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://img.lus.red/blog/CSjfFY.png" alt="封面" style="zoom:50%;"></p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">主观评分: 8.5</span><br><span class="line">阅读时间: 2h(粗读)</span><br><span class="line">一句话点评: 通过分析二进制,区分分支覆盖,并且辅以推荐系统,来达到精确测试.</span><br></pre></td></tr></table></figure><a id="more"></a><p>发现测试那边人手一本&lt;不测的秘密–精准测试之路&gt;, 借阅了以后大概的粗略看了下.</p><p>目前我们测试也发现了这样一个问题, 因为测试和开发是分离的, 所以开发说只修改了一行代码, 测试怎么确保你所修改的影响范围呢? 大家都知道墨菲定律, 所以这个时候看似最靠谱的策略就是<strong>全部重测</strong>…</p><p>本书的作者就是通过一个个小故事, 来讲述怎么样去精准的测试, 只测试受影响的. 具体的做法就是通过分析二进制文件, 根据调用链来确定对测试用例的影响, 后续辅以推荐系统, 做到自动推荐受影响的测试范围.</p><p>但是腾讯的书的通病, 书里提到的东西… 都是不开源的…</p><p>上次看&lt;腾讯游戏开发&gt;就很头痛了, 讲了一堆我们做了个巴拉巴拉的东西, 思路是怎么样怎么样的.. 结果一看, 不开源的, 都是内部用的, 照着来做一个, 不知道要踩多少坑. 这个也是, 虽然没有开动, 但是肉眼可见的, 又是一个看上去很美的项目…</p><p>暂时先这样, 等后续考虑TDD的时候再想想这个是不是可以集成进去.</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://img.lus.red/blog/CSjfFY.png&quot; alt=&quot;封面&quot; style=&quot;zoom:50%;&quot;&gt;&lt;/p&gt;
&lt;figure class=&quot;highlight plain hljs&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;主观评分: 8.5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;阅读时间: 2h(粗读)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;一句话点评: 通过分析二进制,区分分支覆盖,并且辅以推荐系统,来达到精确测试.&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="读书笔记" scheme="http://nas.lus.red/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="测试" scheme="http://nas.lus.red/tags/%E6%B5%8B%E8%AF%95/"/>
    
      <category term="精准测试" scheme="http://nas.lus.red/tags/%E7%B2%BE%E5%87%86%E6%B5%8B%E8%AF%95/"/>
    
      <category term="读书笔记" scheme="http://nas.lus.red/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>&lt;代码精进之路--从码农到工匠&gt;读后感</title>
    <link href="http://nas.lus.red/%E4%BB%A3%E7%A0%81%E7%B2%BE%E8%BF%9B%E4%B9%8B%E8%B7%AF-%E4%BB%8E%E7%A0%81%E5%86%9C%E5%88%B0%E5%B7%A5%E5%8C%A0-%E8%AF%BB%E5%90%8E%E6%84%9F.html"/>
    <id>http://nas.lus.red/代码精进之路-从码农到工匠-读后感.html</id>
    <published>2020-01-22T12:42:05.000Z</published>
    <updated>2020-01-22T14:18:00.265Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://img.lus.red/blog/R7zJd7.png" alt="封面" style="zoom:50%;"></p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">主观评分: 9.5</span><br><span class="line">阅读时间: 6(粗读)</span><br><span class="line">一句话点评:</span><br></pre></td></tr></table></figure><a id="more"></a><p>[toc]</p><p>原本以为这本只是一本跟风之作, 因为&lt;程序员修炼之道–从小工到专家&gt;实在是太有名了, 导致后续不少书都有类似从xx到xx之类的副标题, 而且质量又良莠不齐, 特别容易引人浮躁. 但是这本书不同, 这本书可以说是今年至今为止让我最爱不释手的一本了, 忍不住想要好好精读一遍.</p><p>为什么这本书让我爱不释手?<br>因为这本书解决了好几个我心中的疑惑, 但是又不知如何去描述的问题, 等看到了相关章节, 真的有一种aha moment的感觉, 个中滋味, 如人饮水, 冷暖自知.</p><p>“愿天下没有烂代码”, 这本书以此为切入点, 首先描述了一些编程技巧和方法论, 然后从更高层次的思想指导, 来统领方法论和技巧, 特别是对于技术Leader的职责给出了切实有效的建议, 最后则是结合了一些实践, 包括他们自研的COLA架构和落地.</p><p>全书之中, 对我最有价值的部分莫过于技术Leader这个章节了. 因为我本身也是突然变成了这样一个定位, 挺迷茫自己究竟要做什么, 而作者对于技术Leader和Manager的分析, 让人恍然大悟, 作者还辅以OKR, CodeReivew, 技术规划等等一系列切实有效的技术Leader工作, 受益匪浅, 待开年后心里就有谱了.</p><p>并且这本书也可以作为一个技术目录使用, 因为很多点其实作者只是浅尝辄止, 并未有特别深入去说明, 完全可以在后续进行补充.</p><h2><span id="命名">命名</span></h2><h3><span id="有意义的命名">有意义的命名</span></h3><p>变量名应该是名词, 能够正确地描述业务, 有表达力.</p><p>函数命名要具体, 空乏的命名没有意义. 函数的命名要体现做什么, 而不是怎么做.</p><p>类分成两大类: 试题类和辅助类. 实体类承载了核心业务数据和核心业务逻辑, 其命名要充分体现业务语义, 辅助类是辅助实体类一起完成业务逻辑的, 其命名要能够通过后缀来体现功能.</p><p>包代表了一组有关系的类的集合, 起到分类组合和命名空间的作用.</p><h2><span id="规范">规范</span></h2><p>发现共通抽象和机制, 可以在很大程度上帮助我们理解复杂系统.</p><h3><span id="日志规范">日志规范</span></h3><p>Error表示不能自己恢复的错误, 需要立即被关注和解决.</p><p>Warn, 对于可预知的业务问题, 最好不要用Error输出日志, 以免污染报警系统. 例如: 参数校验不通过, 没有访问权限等<strong>业务异常</strong>, 就不应该用Error输出.</p><p>Info用于记录系统的基本运行过程和运行状态.</p><h3><span id="异常规范">异常规范</span></h3><h4><span id="异常处理">异常处理</span></h4><p>很多应用系统因为没有同意的异常处理规范, 增加了认为的复杂性:</p><p>(1) 代码中导出充斥着异常捕获的try/catch, 搞乱了代码结构, 把错误处理和正常流程混为一谈, 严重影响了代码的可读性.</p><p>(2) 异常处理不统一, 有的场景对外直接抛出异常, 有的场景对外返回错误码, 这种不一致性让服务的调用方摸不着头脑, 增加了服务的使用成本和沟通成本.</p><p>针对以上问题, 建议在业务系统中设定两个异常, 分别是业务异常和系统异常.</p><h2><span id="设计原则">设计原则</span></h2><p>SOLID.</p><p>Single Responsibility Principle. (SRP) 单一职责原则.</p><p>Open Close Principle. (OCP) 开闭原则,</p><p>Liskov Substitution Principle. (LSP) 里式替换原则.</p><p>Interface Segregation Principle. (ISP) 接口隔离原则.</p><p>Dependency Inversion Principle. (DIP) 依赖倒置原则.</p><p>Don’t Repeat Yourself. (DRY)</p><p>You Ain’t Gonna Need It.(YAGNI)</p><p>Rule Of Three. (第三次出现时, 才开始抽象化)</p><p>Keep It Simple and Stuipid. (KISS)</p><p>Principle of least astonishment. (POLA) 最小惊奇原则.</p><h2><span id="设计模式">设计模式</span></h2><p>模式不是框架, 也不是过程. 模式不是简单的”问题的解决方案”, 必须是典型问题的解决方案, 是可以让学习者举一反三的, 是理论和实践之间的中介环节. 模式具有一般性, 简单性, 重复性, 结构性, 稳定性和可操作性等特征.</p><h2><span id="技术leader的修养">技术Leader的修养</span></h2><h3><span id="技术氛围">技术氛围</span></h3><p>一个技术团队, 不管大小, 如果没有”技术味道”, 那么技术Leader负有很大的责任.</p><h4><span id="代码好坏味道">代码好坏味道</span></h4><p>周会的主持人需要给大家分享3个代码好味道和3个代码坏味道代码, 这些代码既可以是来自我们工作中的代码, 也可以是来自开源软件的源码.</p><h4><span id="技术分享">技术分享</span></h4><p>分享是倒逼我们区学习和总结的有效手段</p><h4><span id="cr周报">CR周报</span></h4><p>各种Code Review的方式都很好, 但是有一个共同的缺点, 就是很难将过程透明化.</p><p>CR周报就是要把CR的结果透明化, 通过周报的形式展现团队在一周中的CR成果, 包括团队成员的CR评论排名, 代码分支的质量情况, 以及CR中的典型案例. 这种透明化非常有价值, 既可以帮助技术Leader了解代码质量的概况, 也能极大地调用团队成员进行CR的积极性.</p><h4><span id="读书会">读书会</span></h4><p>书的范围可以放宽一点, 读书的形式可以是同读一本书, 也可以是拆书. 读书会的举办频率可以灵活一些.</p><h3><span id="目标管理">目标管理</span></h3><h3><span id="技术规划">技术规划</span></h3><p>技术规划更多的是从团队视角去看接下来要做的事情, 而目标管理师要把规划要做的事情进行拆解, 和个人目标对齐. 做好技术规划是非常重要的事情, 一个团队有没有价值, 最终还是要通过做出来的事情来体现.</p><h4><span id="当前问题">当前问题</span></h4><p>主要看团队中现在有什么迫切, 紧急的问题要解决, 有什么坑要去填.</p><h4><span id="技术领域">技术领域</span></h4><p>在常规领域中, 根据业务情况和团队情况选择一些领域和命题(比如稳定, 性能, 效率等), 并在这些命题和方向中根据优先级做判断.</p><h4><span id="业务领域">业务领域</span></h4><p>充分了解业务, 关注业务, 要分析业务数据和发展趋势, 和业务同事充分交流, 总结和抽象出业务的发展对技术会提出什么诉求, 需要技术做什么布局和建设以应对业务发展的需求.</p><h4><span id="团队特色">团队特色</span></h4><p>对比团队内外技术的异同, 最终圈定一个差异化区域.</p><h3><span id="leader和manager的区别">Leader和Manager的区别</span></h3><p>Manager是管理事务, 是控制和权威; 而Leader是领导人心, 是引领和激发.</p><p>我们不需要这么多高高在上, 指点江山的技术Manager, 而是需要更多能够真正深入系统里面, 深入代码细节, 给团队带来改变的技术Leader.</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://img.lus.red/blog/R7zJd7.png&quot; alt=&quot;封面&quot; style=&quot;zoom:50%;&quot;&gt;&lt;/p&gt;
&lt;figure class=&quot;highlight plain hljs&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;主观评分: 9.5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;阅读时间: 6(粗读)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;一句话点评:&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="读书笔记" scheme="http://nas.lus.red/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="读书笔记" scheme="http://nas.lus.red/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
      <category term="方法论" scheme="http://nas.lus.red/tags/%E6%96%B9%E6%B3%95%E8%AE%BA/"/>
    
      <category term="代码质量" scheme="http://nas.lus.red/tags/%E4%BB%A3%E7%A0%81%E8%B4%A8%E9%87%8F/"/>
    
  </entry>
  
  <entry>
    <title>学习路线</title>
    <link href="http://nas.lus.red/%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF.html"/>
    <id>http://nas.lus.red/学习路线.html</id>
    <published>2020-01-14T16:05:38.000Z</published>
    <updated>2020-01-14T17:02:46.889Z</updated>
    
    <content type="html"><![CDATA[<p>临近年关了, 最近的工作重心也落到了聊聊绩效和未来一年的规划, 能够感受到大家的对未来的憧憬, 也有很多迷茫和彷徨, 但是总体来说氛围还是比较向上的.</p><p>因为最近Review了不少代码, 有相当一部分是我自己不熟悉的功能, 需要花费一些精力去了解背后的逻辑, 所以愈发觉得自己还是太菜了, 想做的想学的很多, 但是如何去做好它, 可能真的需要花费一番功夫.</p><h2><span id="怎样学习">怎样学习</span></h2><p>怎么样去学习? 大多数人脑中的第一反应是看书. 看书能够提供系统性的知识, 对于个人学习还是非常有帮助的. 但是看书又往往是效率很低的, 网上有这样的说法, 虽然不能全信, 但还是有一点道理的:</p><p>只是听讲，在一个月之后就剩下5%；</p><p>只是阅读，在一个月之后就剩下10%；</p><p>只是视听，在一个月之后就剩下20%；</p><p>经常看演示，在一个月之后就剩下30%；</p><p>经常讨论，在一个月之后就剩下50%；</p><p>经常实践，在一个月之后就剩下75%；</p><p>把学到的知识教授给他人，在一个月之后能剩下90%！</p><p>教授这事儿相对而言会麻烦点, 那么我们可以选择实践!</p><h2><span id="学习什么">学习什么</span></h2><p>聊了一段时间后, 我发现OKR(目标管理)非常适合学习这个场景.</p><p>目标管理的核心是什么? 具有挑战性的积极目标 + 量化的关键结果 + 持续的反馈.</p><p>所以我就问了新人, 你的目标是什么?  “学好C#”.</p><p>那我们的目标就是学好C#, 那你怎么去衡量自己学好了C#呢?</p><p>是看完了&lt;精通C#&gt;, 看完了&lt;C#本质论&gt;还是看完了Channel9上的C#视频?</p><p>都不是, 这些只是过程, 哪怕你完成了, 也并不能证明你学好了C#.</p><p>这个时候你就应该去找关键结果, 能够用来量化你学好C#的证明.</p><p>比如说, 熟练掌握了C#的语言特性XML特性, 能够使用XML开发一个RSS订阅软件.</p><p>而且, 还要<strong>加上时间</strong>, 不要过短, 不宜过长. 两个月, 足矣.</p><p>当你能把所有的关键结果都讲清楚了, 想清楚了, 你的路子就不会歪了.</p><p>可惜我C#不行, 所以讲不出太多.</p><h2><span id="语言学习">语言学习</span></h2><p>其实语言的学习, 我个人倒是觉得最简单. 为什么? 因为目标明确.</p><p>任何一种语言, 不管你是python还是汇编, 总之离不开这样的几个过程:</p><ul><li><p>掌握语言特性. 这里基本上就是语法啊, 特性啊, 常用库之类, 看本身复杂度, 短则几天, 长则数月.</p></li><li><p>熟练应用. 这个阶段可能会持续很长, 并且每个人的环境, 压力不同, 所以成长速度不一定, 在这个阶段, 会开始逐渐深入, 当然更多人可能会因为没有持续的输入或者输出, 出现了”瓶颈”.</p></li><li>设计. 这个阶段就是俗称的”造轮子”, 自己写库, 自己深挖编译器… 不一而足.</li></ul><p>就以我熟悉的C++而言,</p><p>第一阶段, 掌握语言特性, <essential c++="">了解编程范式, &lt;C++ Primer&gt;学习语法和STL, 配合一定量的练习, 你就已经入门, 可以干活了.</essential></p><p>第二阶段, 一方面是随着代码的越写越多, 你需要总结经验和继续深入, 这个时候你可能就要开始看<effective c++="">, <more effective="" c++="">, &lt;深入探索C++对象模型&gt;, &lt;STL源码剖析&gt;, &lt;STL标准库&gt;… 另一方面则是广度, 你开始接触更多设计的, 架构的方法和思想, 所以&lt;设计模式 可复用面向对象软件的基础&gt;, &lt;代码整洁之道&gt;, &lt;重构 改善既有代码的质量&gt;, &lt;领域驱动设计&gt;之类的悄悄爬上了你的书桌.</more></effective></p><p>第三阶段, 你开始想要去了解更多的细节, 挖掘更多深层次的内容. 看源码, 自己写库, 并且N多C++程序员最爱的工作造轮子就会发生在此时.</p><p>其实还有很多想法, 但是总觉得太过碎片化, 可能以后留着更新吧</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;临近年关了, 最近的工作重心也落到了聊聊绩效和未来一年的规划, 能够感受到大家的对未来的憧憬, 也有很多迷茫和彷徨, 但是总体来说氛围还是比较向上的.&lt;/p&gt;
&lt;p&gt;因为最近Review了不少代码, 有相当一部分是我自己不熟悉的功能, 需要花费一些精力去了解背后的逻辑, 所
      
    
    </summary>
    
    
      <category term="C++" scheme="http://nas.lus.red/tags/C/"/>
    
      <category term="C#" scheme="http://nas.lus.red/tags/C/"/>
    
      <category term="学习路线" scheme="http://nas.lus.red/tags/%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/"/>
    
  </entry>
  
  <entry>
    <title>没有硝烟的战场--索罗斯 VS 香港</title>
    <link href="http://nas.lus.red/%E6%B2%A1%E6%9C%89%E7%A1%9D%E7%83%9F%E7%9A%84%E6%88%98%E5%9C%BA-%E7%B4%A2%E7%BD%97%E6%96%AF-VS-%E9%A6%99%E6%B8%AF.html"/>
    <id>http://nas.lus.red/没有硝烟的战场-索罗斯-VS-香港.html</id>
    <published>2020-01-11T14:29:16.000Z</published>
    <updated>2020-01-11T15:03:01.984Z</updated>
    
    <content type="html"><![CDATA[<p>最近刷B站有点多, 主要是为了学习, 然后关注了一波涨姿势的UP主.</p><p>其中<strong>巫师财经</strong>是我收藏夹里已经躺了老久了, <strong>lKs</strong>之前有一期视频, 讲述视频拍摄成本中, 就拿<strong>党妹</strong>, <strong>巫师财经</strong>等人举了例子, 其中对于<strong>巫师财经</strong>不乏溢美之词, 在他们去拍摄<strong>百万奢侈品进当铺</strong>那一集中, 富婆<strong>十音</strong>也直接一句不介绍了, 有兴趣的请去看巫师财经节目云云.</p><p>然后今天看了后, 真香!</p><a id="more"></a><p><iframe src="//player.bilibili.com/player.html?aid=76976895&cid=131705253&page=1" height="800" width="600" scrolling="true" border="0" frameborder="no" framespacing="0" allowfullscreen="true"> </iframe><br>UP主思路明确, 切入点出色, 将索罗斯做空这十余年的大事娓娓道来, 巧妙的降维到幼儿园, 保证了整个叙述的完整性.</p><p><iframe src="//player.bilibili.com/player.html?aid=71420798&cid=123730890&page=1" width="600" height="800" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true"> </iframe><br>另一篇保时捷大众的大战, 虽然已经过去了十数年, 但是详细的资料依然令人动容.</p><p><iframe src="//player.bilibili.com/player.html?aid=68401584&cid=118551810&page=1" height="800" width="600" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true"> </iframe><br>这个视频则是让人对于金融从业者有了更多的了解.</p><p>其他的做了一些明星和奢侈品之类相关的, 有点蹭热度试探粉丝的感觉, 而且据说作者从中行离开后也开始自己创业了, 希望以后不要变成了恰饭视频…</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近刷B站有点多, 主要是为了学习, 然后关注了一波涨姿势的UP主.&lt;/p&gt;
&lt;p&gt;其中&lt;strong&gt;巫师财经&lt;/strong&gt;是我收藏夹里已经躺了老久了, &lt;strong&gt;lKs&lt;/strong&gt;之前有一期视频, 讲述视频拍摄成本中, 就拿&lt;strong&gt;党妹&lt;/strong&gt;, &lt;strong&gt;巫师财经&lt;/strong&gt;等人举了例子, 其中对于&lt;strong&gt;巫师财经&lt;/strong&gt;不乏溢美之词, 在他们去拍摄&lt;strong&gt;百万奢侈品进当铺&lt;/strong&gt;那一集中, 富婆&lt;strong&gt;十音&lt;/strong&gt;也直接一句不介绍了, 有兴趣的请去看巫师财经节目云云.&lt;/p&gt;
&lt;p&gt;然后今天看了后, 真香!&lt;/p&gt;
    
    </summary>
    
      <category term="财经" scheme="http://nas.lus.red/categories/%E8%B4%A2%E7%BB%8F/"/>
    
    
      <category term="财经" scheme="http://nas.lus.red/tags/%E8%B4%A2%E7%BB%8F/"/>
    
      <category term="视频" scheme="http://nas.lus.red/tags/%E8%A7%86%E9%A2%91/"/>
    
  </entry>
  
  <entry>
    <title>&lt;程序员的三门课&gt;读书笔记</title>
    <link href="http://nas.lus.red/%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E4%B8%89%E9%97%A8%E8%AF%BE-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0.html"/>
    <id>http://nas.lus.red/程序员的三门课-读书笔记.html</id>
    <published>2020-01-10T15:39:04.000Z</published>
    <updated>2020-01-22T14:17:53.815Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://img.lus.red/blog/VMLRY0.png" alt="封面"></p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">主观评分: 7</span><br><span class="line">花费时间: 8h(粗读)</span><br><span class="line">一句点评: 这是一个IT人实践的记录, 作者想要讲得广, 不知是限于篇幅还是自身能力, 最后变成了水.</span><br></pre></td></tr></table></figure><a id="more"></a><p>[toc]</p><p>作为一个爱囤书的仓鼠党, 每月惯例就是看看有啥子新书可以买买买, 在新书里看到了这本&lt;程序员的三门课–技术精讲 架构设计 管理探秘&gt;, 书的内容分为三大部分:</p><ul><li><p>介绍程序员的技能成才路径</p></li><li><p>架构思维模式, 架构设计过程</p></li><li><p>做技术管理的的诀窍</p></li></ul><p>看着就是干货满满, 包罗万象的样子, 虽说按照一般经验来说, 国内作者这种样样通的书往往会很水 但是还是欣然购入喜加一.</p><p>本书主要是于泽君的自己的一些理解和感悟, 和自己成长过程中的新路历程及他的一些总结, 同时也邀请了其他4位作者一起合作的书, 可以看出来, 不管是行书的结构还是字里行间, 还是以他为主, 其他人为辅助, 他的技术栈是以<strong>Java</strong>为主, 在架构方面, 也以<strong>领域模型</strong>和<strong>分层</strong>介绍得最为详细, 而管理相关的就相对没有那么系统性的方法论, 而是更多零碎的个人经验.</p><p><strong>史海峰</strong>的推荐序我个人甚是喜欢, 他讲述的是<strong>世界上需要什么样的程序员</strong>, 他认为好的程序员应该是<strong>工型人才</strong>, 一横: 具备完成完整应用的能力, 包括运维, 成为熟手; 一纵:在某些领域足够深入, 成为高手; 一横: 达到更高水平后, 兼容多个领域, 成为驱动着和领导者. </p><h2><span id="程序员的技能与成长">程序员的技能与成长</span></h2><h3><span id="如何学习一门新语言">如何学习一门新语言</span></h3><p>在学习一门语言时, 重点应该关注三个点: <strong>基本表达形式</strong>, <strong>组合的方法</strong>, <strong>抽象的方法</strong>.<br>这三点对应的其实就是三个点: 基础知识, 应用和设计.</p><p>动态语言, 静态语言, 强类型语言, 弱类型语言, 编译型语言, 解释型语言, 都要浅尝辄止.<br>只有看多了, 你才能更加领略每种语言的其中三味, 所以我打算后面先学Python, 然后LISP, 这里先立个Flag.</p><p>我记得C语言之父在写<essential c++="">的时候就提到了关于学习的一些话题, 在完成了史诗般巨作的&lt;C++ Primer&gt;之后, 他发现这本砖头书实在是不适合入门, 所以他回头头来写了<essential c++="">, 在这本书, 他不再按照面面俱到的细数所有C++特性, 而是将C++的几种编程范式, 通过精心准备的由浅入深的例子来呈现. 虽然我了解到这本书的时候已经过了入门这个槛了, 但是看看还是收益良多的. </essential></essential></p><p>因为语言不仅仅是语法, 在刚开始学习的时候, 总觉得像&lt;精通Visual C++&gt;这种书, 简单又明了, 所有概念都分门别类, 一条条的特别清楚. 直到自己用了多年, 才感受到语言自有魅力和逻辑, 而不仅仅是搬砖那么简单.</p><p>其他的一些经验, 比如带着问题去学习, 勤加练习, 教学相长之类的, 都算是老生常谈了.</p><h3><span id="测试驱动开发">测试驱动开发</span></h3><p>作者似乎非常推崇测试驱动开发, 他提到了自己曾经做了一件现在看起来不靠谱的事情, 就是把一个模块的代码测试覆盖率达到了80%, 但是测试覆盖率低的原因往往是:</p><ul><li><p>团队成员没有写测试的习惯, 没有意识到其重要性, 不想写</p></li><li><p>代码难于测试, 不会写</p></li><li><p>赶进度, 没有时间写</p></li></ul><p>相比于提高覆盖率, 解决这些问题更加重要, 代码覆盖率的提升, 从本质上来说并不是解决这些问题的良药, 糟糕的代码哪怕你提高了测试覆盖率, 在面对新需求时, 可能又是一堆无效且累赘的代码.</p><p>这件事我感受颇为深刻, 因为同样的事情我也做过, 然后半途而废了. 为啥? 因为我发现单元测试虽然能对代码质量有所帮助, 但是更大的问题其实在于糟糕的设计, 抱歉真的是非常糟糕, 而且很多还是自己挖的坑, 可能真的是需要重构这把钥匙才有希望解决这些问题, 如今的自己还是没有真正的想好, 后面应该怎么样做.我们不仅违反了测试驱动设计的步骤, 甚至还违反了同步编写开发代码和测试代码的思路, 可能过年的时候, 自己好好实践下, TDD是不是真的是灵丹妙药了. </p><p>然后作者这里就开始水了N页, 去给出了一个TDD的操作例子, 没办法, Java的框架巴拉巴拉的代码一写上, 动辄就是一页的代码, 这个我还是觉得&lt;C++程序设计与实践: 测试驱动开发&gt;这本书写得更详尽和深入一点.</p><h3><span id="静态代码分析">静态代码分析</span></h3><p>作者分享了一些Java的静态代码分析工具, 对于一个CLike语言的使用者, 又是几大章跳过的内容, 目前自用的CppCheck和Visual Studio的代码分析工具还是挺好用的.</p><h3><span id="代码审查">代码审查</span></h3><p>这一章对我而言感觉非常重要, 因为自己最近也在做代码审查工作, 但是效果不好(虽然总有一种正在渐入佳境的错觉), 个人思来想去外加问大佬后的最终结论是: <strong>自己太菜了</strong>.为什么审核不出结果? 是因为自己太菜了, 全程都没法跟上别人的思路, 那除了简单的看看逻辑有没有错误, 谈何从设计从更高的层次去发现问题?</p><p>关于代码审查, 从一个评审人的角度, 我个人的观点是这样的:</p><ul><li><p>将代码放在整个环境去中看, 并不是一个片段, 除非你很熟悉, 不然光Diff不是一个优秀的审查方法</p></li><li><p>代码审查是一个持续性的工作, 快速的反馈, 不懂就问</p></li><li><p>代码审查不仅是个审查的机会, 更是个学习的机会</p></li></ul><p>而作者似乎对工具比较推崇, 认为工具和检查清单在整个代码审查过程中都很重要, 这点我只能说认同一半吧, 工具只是提高效率, 但是更多的功夫是在评审之外的.</p><h3><span id="工具化">工具化</span></h3><p>对于统一的工具平台, 需要考虑不同工具的层次, 使其能够尽量的复用; 对于差异较大的, 则分别建设.</p><p>我发现作者似乎对于工具和自动化特别的推崇, 可能是我对Java的理解还停留在以前使用Eclipse开发的古老年代, 在那个年代Java中有大量大量的简单而又机械的工作, C++程序员老是在造轮子….</p><h3><span id="自动化">自动化</span></h3><p>自动化测试作为有效的提效手段, 是每个技术团队都在追求的目标. 核心问题有两个: <strong>分层</strong>和<strong>稳定</strong>.</p><p>分层: 各种复杂功能需要不同的粒度来保证, 单元测试, 组件测试, 接口测试, 灰度测试等需要结合使用.</p><p>稳定: 持续集成的基础, 自动化屏蔽了逻辑的细节, 将前人的测试经验代码化了, 所以引入了一个测试成熟度: 一方面评价代码覆盖, 另一方面评价CI的通过率.</p><h3><span id="文档">文档</span></h3><p>又是一个痛点. 传统的文档管理方式, 总是让人迷失在文档的海洋里…</p><p>作者的几个观点虽然比较零碎, 但也有一定的道理:</p><ul><li>研发过程的关键文档: 需求和系统分析</li><li>Core文档, 必须定期维护</li><li>用例即文档</li><li>API接口生成</li></ul><h3><span id="程序员的工具箱">程序员的工具箱</span></h3><p>Perl之父Larry Wall提到: 程序员的三个美德是懒惰, 懒惰和懒惰. 作者在这里提到了许多能够提升程序员工作效率的软硬件, 还有在线工具.</p><h2><span id="加速成长与学习">加速成长与学习</span></h2><p>积极主动, 选择合适的平台, 别怕犯错, 注意细节, 时间管理, 打破边界, 带着思考写代码.</p><p>其实我认为最最重要的两点就是时间管理和带着思考写代码.</p><p>时间管理这个问题有点老生常谈了, 但是作者关于会议的一些经验, 还是很有帮助的:</p><ul><li>参加必要的会议, 尽量避免参加不必要的会议.</li><li>尽量不要让不紧要的讨论打断正在做的事情</li><li>可以提前约定时间, 不需要再专注于代码的时间段打扰自己</li></ul><p>然后就是重要紧急四象限, 优先做重要的事情!</p><p>带着思考去写代码也很重要, 写代码也分几个层次: </p><ul><li>第一个层次, 让代码写得不一样, 规范性, 可读性, 可扩展性…</li><li>第二个层次, 考虑业务问题和技术问题的匹配, 可以从写业务代码中理解需求, 做好分析和设计.</li><li>第三个层次, 总结相关方法体系, 成为业务及技术的双料专家.</li></ul><h3><span id="学会学习">学会学习</span></h3><p>管理好自己的目标, 利用好碎片化时间, 一次只做一件事.</p><h4><span id="两个著名的学习理论">两个著名的学习理论</span></h4><h4><span id="德雷福斯模型">德雷福斯模型</span></h4><p>一种衡量人们的工作方法和能力, 反省并提高专业技能的层级模型:</p><ul><li>新手: 需要指令清单, 很少的经验, <strong>通过模仿和观察来学习</strong></li><li>高级新手: 不需要全局思维, 可以独立尝试任务, 但扔难以解决问题</li><li>胜任者: 能够解决问题</li><li>精通者: 能够自我纠正, 需要全局思维, 将围绕某种技术, 寻找并想了解更大的概念框架</li><li>专家: 专家凭借直觉工作, 有丰富的经验, 可以在前挡的情境中选取和应用自己的经验, <strong>需要保持实践来维持水平</strong></li></ul><h4><span id="刻意锻炼理论">刻意锻炼理论</span></h4><p>专家水平是可以训练出来的.</p><h2><span id="业务分析与设计">业务分析与设计</span></h2><p>用特定的方式或方法, 把复杂的需求拆解成更简单并且容易理解的对象, 并找出这些对象间的关系</p><h3><span id="领域驱动设计ddd">领域驱动设计(DDD)</span></h3><p>领域驱动设计提出了领域模型的概念, 抛弃了将分析与设计分开的做法, 使用统一的模型来满足分析与设计的需求. 领域设计 = 边界 + 设计; 有界上下文 = 用户 + 领域 + 功能. 那么领域驱动设计就是一种定义边界, 并且在设计阶段融合了原形的设计方法?</p><p>领域驱动设计的三个核心原则:</p><ul><li>把项目的重点放在核心域和域逻辑上</li><li>把复杂的设计放在有界域模型上</li><li>和领域专家不断协作晚上应用模型来解决特定领域的问题</li></ul><p>领域驱动设计就是先将领域中涉及的数据,流程,商业规规则等都弄明白, 然后以面向对象的观点为其建立一个领域模型, 再选用合适的软件技术实现这个模型. 问题域就是数据, 流程和规则; 问题解决域就是用软件去实现这个模型.</p><p><strong>后续需要补充一些相关资料来学习, 作者这里写得太乱了, 看着吃力</strong></p><h2><span id="架构修炼">架构修炼</span></h2><h3><span id="分解">分解</span></h3><p>高内聚, 低耦合; 层次性; 正交原则(分层后都是独立的); 抽象; 稳定; 复用</p><h3><span id="复用">复用</span></h3><p>可扩展性, 灵活性, 可插入性.一个复杂性较好的系统, 就是一个易维护的系统.</p><p>为了可维护性, 我们有一些原则:</p><ul><li><p>开闭原则</p><p>抽象化是开闭原则的关键, 可以为系统定义一个稳定的抽象层, 将不同的实现行为移至具体的实现层.</p></li><li><p>LSP里氏代换原则</p><p>将基类替换成子类对象不会有任何错误, 这个就是实现开闭原则的重要方式之一.</p></li><li><p>DIP依赖倒置</p><p>依赖于抽象而不是实现</p></li><li><p>ISP接口隔离原则</p><p>每个接口应该承担一种相对独立的角色,不干不该干的事情.</p></li><li><p>CARP组合聚合复用原则</p><p>尽量使用组合或聚合关系,少用继承. 使用继承复用会破坏系统的封装性.</p></li><li><p>LoD迪米特法则</p><p>尽量减少对象直接的通信</p></li></ul><h3><span id="模式">模式</span></h3><p>根据业务需求来选择最合适的技术, 而不是用主流和最先进的技术去反推业务.</p><p>作者介绍了一些模式, 但都比较简单, 我觉得后面可以专门写一篇模式相关的文章来说这个问题, 这里仅做简单的说明, 而且我觉得这里虽然都是模式,但是领域不一样, 放在一起写挺奇怪的…</p><ul><li><p>分层</p><p>每层只能与位于其下方的层发生耦合, 四层/五层/六边形架构都是领域驱动比较经典的架构.</p></li><li><p>C/S</p><p>客户端/服务器模式</p></li><li><p>主从</p></li><li><p>管道-过滤器</p><p>一种松耦合的设计模式, 各过滤器只需要实现单一功能, 降低了依赖和复杂度</p></li><li><p>代理</p><p>在结构和系统中对组件进行解耦, 组件之间都过RPC的方式进行交互, 代码组件则用于协调.</p></li><li><p>P2P</p></li><li><p>事件总线</p><p>事件源, 事件监视器, 通道和事件总线.</p></li><li><p>MVC</p></li><li><p>黑板</p><p>观察者模式的扩展, 包括知识源, 黑板数据和控制; 相比观察者, 多了黑板数据模式匹配.</p></li><li><p>解释器</p></li></ul><h3><span id="结构化">结构化</span></h3><p>Who, What, When, Where, Why, How, How much</p><h3><span id="架构设计">架构设计</span></h3><p>稳定, 解耦, 抽象, 松耦合, 容错</p><h3><span id="技术架构">技术架构</span></h3><p>无状态, 可复用, 松耦合, 可治理, 基础服务(这个是适用于网络的)</p><h3><span id="架构设计的流程">架构设计的流程</span></h3><p>这里作者提到了学习<strong>元模型</strong>, 来自己设计, 后续给出的都是Web开发的一些例子, 就暂时不看了.</p><h2><span id="质量与风险">质量与风险</span></h2><h3><span id="pdca">PDCA</span></h3><p>Plan, Do. Check, Act</p><h3><span id="可能引起质量问题的坑">可能引起质量问题的坑</span></h3><p>业务发展, 问题域的复杂性, 系统的复杂性, 技术债, 人/流程/文档的博弈, 采用不能掌控的工具和框架, 质量意识</p><h2><span id="管理">管理</span></h2><p>必须的技能准备, 视角转换, 学会用户思维, 建立经济视角, 成为内部商务合作, 规划团队从规划自己开始, 数据驱动</p><p>技术领导力4个维度:</p><ul><li>提供清晰的领导力风格, 并以信任感作为基石</li><li>了解业务, 并带领团队到到高绩效</li><li>发展自己和团队成员</li><li>塑造未来</li></ul><p>让自己成为T型人才:</p><ul><li>离开舒适区</li><li>坚持阅读和与不同领域的人交流</li><li>创造需求, 基石应用和实践自己掌握的知识</li><li>尝试训练自己动多角度看待问题</li><li>给学习和应用设定目标和里程碑</li></ul><p>高效管理时间:</p><ul><li>确定在做的事情符合自己的目标</li><li>随时应用80/20法则</li><li>创造大块的时间</li></ul><p>如何解决不服的员工</p><p>如何处理冲突</p><p>如何管理更多人员</p><p>从管理这章而言, 我最大的体会还是自己把时间和精力都花在了不重要的事情上, 导致整个团队的效率是在下降的, 后续会思考如何让我们整个团队保持一个更高的效率!</p><h2><span id="总结">总结</span></h2><p>总得看下来, 这本书的质量其实并不高, 里面很多的内容其实是作者的经验谈, 结合了一些比较泛泛的方法论, 组织上追求全而缺乏核心主题, 所以不是很系统, 看上去就特别空, 有一种背概念的感觉. </p><p>其中的一些经验比如说团队管理和个人管理, 对我个人而言, 还是很有借鉴和帮助的, 但是技术路线就差的比较远了.</p><h2><span id="todo">TODO</span></h2><p>了解DDD领域驱动设计</p><p>使用TDD开发一个小项目</p><p>整理书中提到的模式和应用场景</p><p>在团队中尝试使用OKR的方式来管理目标</p><p>使用德雷福斯模型分析团队现状, 并制定发展规划</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://img.lus.red/blog/VMLRY0.png&quot; alt=&quot;封面&quot;&gt;&lt;/p&gt;
&lt;figure class=&quot;highlight plain hljs&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;主观评分: 7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;花费时间: 8h(粗读)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;一句点评: 这是一个IT人实践的记录, 作者想要讲得广, 不知是限于篇幅还是自身能力, 最后变成了水.&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="读书笔记" scheme="http://nas.lus.red/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="读书笔记" scheme="http://nas.lus.red/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
      <category term="方法论" scheme="http://nas.lus.red/tags/%E6%96%B9%E6%B3%95%E8%AE%BA/"/>
    
      <category term="程序员" scheme="http://nas.lus.red/tags/%E7%A8%8B%E5%BA%8F%E5%91%98/"/>
    
  </entry>
  
  <entry>
    <title>lua序列化</title>
    <link href="http://nas.lus.red/lua%E5%BA%8F%E5%88%97%E5%8C%96.html"/>
    <id>http://nas.lus.red/lua序列化.html</id>
    <published>2018-12-07T14:16:57.000Z</published>
    <updated>2018-12-07T14:58:44.420Z</updated>
    
    <content type="html"><![CDATA[<p>将一个表序列化成一个字符串, 逻辑很简单, 就是递归调用 + 类型判断.</p><figure class="highlight lua hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment">-- 字符串序列化 + 缩进</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">serialize</span><span class="hljs-params">(param, level)</span></span></span><br><span class="line">    <span class="hljs-keyword">local</span> result = <span class="hljs-string">""</span></span><br><span class="line">    <span class="hljs-keyword">local</span> space = <span class="hljs-string">""</span></span><br><span class="line">    <span class="hljs-keyword">local</span> t = <span class="hljs-built_in">type</span>(param)</span><br><span class="line">    <span class="hljs-keyword">if</span> (<span class="hljs-literal">nil</span> == level) <span class="hljs-keyword">then</span></span><br><span class="line">        level = <span class="hljs-number">0</span></span><br><span class="line">    <span class="hljs-keyword">end</span></span><br><span class="line">    <span class="hljs-keyword">for</span> i = <span class="hljs-number">1</span>, level <span class="hljs-keyword">do</span></span><br><span class="line">        space = space .. <span class="hljs-string">"\t"</span></span><br><span class="line">    <span class="hljs-keyword">end</span></span><br><span class="line">    </span><br><span class="line">    <span class="hljs-keyword">if</span> t == <span class="hljs-string">"number"</span> <span class="hljs-keyword">then</span></span><br><span class="line">        result = result .. param</span><br><span class="line">    <span class="hljs-keyword">elseif</span> t == <span class="hljs-string">"boolean"</span> <span class="hljs-keyword">then</span></span><br><span class="line">        result = result .. <span class="hljs-built_in">tostring</span>(param)</span><br><span class="line">    <span class="hljs-keyword">elseif</span> t == <span class="hljs-string">"string"</span> <span class="hljs-keyword">then</span></span><br><span class="line">        result = result .. <span class="hljs-built_in">string</span>.<span class="hljs-built_in">format</span>(<span class="hljs-string">"%q"</span>, param)</span><br><span class="line">    <span class="hljs-keyword">elseif</span> t == <span class="hljs-string">"table"</span> <span class="hljs-keyword">then</span></span><br><span class="line">        result = result .. <span class="hljs-string">"&#123;\n"</span></span><br><span class="line">        <span class="hljs-keyword">for</span> k, v <span class="hljs-keyword">in</span> <span class="hljs-built_in">pairs</span>(param) <span class="hljs-keyword">do</span></span><br><span class="line">            result = result .. space .. <span class="hljs-string">"\t"</span> .. <span class="hljs-string">"["</span> .. serialize(k) .. <span class="hljs-string">"] = "</span></span><br><span class="line">            .. serialize(v, level + <span class="hljs-number">1</span>) .. <span class="hljs-string">",\n"</span></span><br><span class="line">        <span class="hljs-keyword">end</span></span><br><span class="line">        </span><br><span class="line">        <span class="hljs-keyword">local</span> metatable = <span class="hljs-built_in">getmetatable</span>(param)</span><br><span class="line">        <span class="hljs-keyword">if</span> metatable ~= <span class="hljs-literal">nil</span> <span class="hljs-keyword">and</span> <span class="hljs-built_in">type</span>(metatable.<span class="hljs-built_in">__index</span>) == <span class="hljs-string">"table"</span> <span class="hljs-keyword">then</span></span><br><span class="line">            <span class="hljs-keyword">for</span> k, v <span class="hljs-keyword">in</span> <span class="hljs-built_in">pairs</span>(metatable.<span class="hljs-built_in">__index</span>) <span class="hljs-keyword">do</span></span><br><span class="line">                result = result .. <span class="hljs-string">"["</span> .. serialize(k) .. <span class="hljs-string">"] = "</span></span><br><span class="line">                .. serialize(metatable.<span class="hljs-built_in">__index</span>[v], level + <span class="hljs-number">1</span>) .. <span class="hljs-string">",\n"</span></span><br><span class="line">            <span class="hljs-keyword">end</span></span><br><span class="line">        <span class="hljs-keyword">end</span></span><br><span class="line">        result = result .. space .. <span class="hljs-string">"&#125;"</span></span><br><span class="line">    <span class="hljs-keyword">elseif</span> t == <span class="hljs-string">"nil"</span> <span class="hljs-keyword">then</span></span><br><span class="line">        <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span></span><br><span class="line">    <span class="hljs-keyword">else</span></span><br><span class="line">        <span class="hljs-comment">-- @warning 不支持表中的function的序列化</span></span><br><span class="line">    <span class="hljs-keyword">end</span></span><br><span class="line">    <span class="hljs-keyword">return</span> result</span><br><span class="line"><span class="hljs-keyword">end</span></span><br></pre></td></tr></table></figure><a id="more"></a><p>测试<br><figure class="highlight lua hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">tb = </span><br><span class="line">&#123;</span><br><span class="line">    a = <span class="hljs-string">'a'</span>,</span><br><span class="line">    b = <span class="hljs-string">"banana"</span>,</span><br><span class="line">    c = &#123;</span><br><span class="line">        <span class="hljs-number">1</span>,</span><br><span class="line">        <span class="hljs-number">2</span>,</span><br><span class="line">        <span class="hljs-number">3</span>,</span><br><span class="line">        hello = <span class="hljs-string">"world"</span></span><br><span class="line">    &#125;,</span><br><span class="line">    d = <span class="hljs-number">10</span>,</span><br><span class="line">    <span class="hljs-string">"e"</span>,</span><br><span class="line">    <span class="hljs-string">"f"</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-built_in">print</span>(serialize(tb))</span><br></pre></td></tr></table></figure></p><p>输出结果<br><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">[1] = &quot;e&quot;,</span><br><span class="line">[2] = &quot;f&quot;,</span><br><span class="line">[&quot;b&quot;] = &quot;banana&quot;,</span><br><span class="line">[&quot;c&quot;] = &#123;</span><br><span class="line">[1] = 1,</span><br><span class="line">[2] = 2,</span><br><span class="line">[3] = 3,</span><br><span class="line">[&quot;hello&quot;] = &quot;world&quot;,</span><br><span class="line">&#125;,</span><br><span class="line">[&quot;a&quot;] = &quot;a&quot;,</span><br><span class="line">[&quot;d&quot;] = 10,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;将一个表序列化成一个字符串, 逻辑很简单, 就是递归调用 + 类型判断.&lt;/p&gt;
&lt;figure class=&quot;highlight lua hljs&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;26&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;27&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;28&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;29&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;30&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;31&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;32&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;33&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;34&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;35&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;36&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;37&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;38&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;39&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;40&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;hljs-comment&quot;&gt;-- 字符串序列化 + 缩进&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;serialize&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(param, level)&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;hljs-keyword&quot;&gt;local&lt;/span&gt; result = &lt;span class=&quot;hljs-string&quot;&gt;&quot;&quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;hljs-keyword&quot;&gt;local&lt;/span&gt; space = &lt;span class=&quot;hljs-string&quot;&gt;&quot;&quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;hljs-keyword&quot;&gt;local&lt;/span&gt; t = &lt;span class=&quot;hljs-built_in&quot;&gt;type&lt;/span&gt;(param)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt; (&lt;span class=&quot;hljs-literal&quot;&gt;nil&lt;/span&gt; == level) &lt;span class=&quot;hljs-keyword&quot;&gt;then&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        level = &lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;hljs-keyword&quot;&gt;end&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;hljs-keyword&quot;&gt;for&lt;/span&gt; i = &lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;, level &lt;span class=&quot;hljs-keyword&quot;&gt;do&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        space = space .. &lt;span class=&quot;hljs-string&quot;&gt;&quot;\t&quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;hljs-keyword&quot;&gt;end&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt; t == &lt;span class=&quot;hljs-string&quot;&gt;&quot;number&quot;&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;then&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        result = result .. param&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;hljs-keyword&quot;&gt;elseif&lt;/span&gt; t == &lt;span class=&quot;hljs-string&quot;&gt;&quot;boolean&quot;&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;then&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        result = result .. &lt;span class=&quot;hljs-built_in&quot;&gt;tostring&lt;/span&gt;(param)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;hljs-keyword&quot;&gt;elseif&lt;/span&gt; t == &lt;span class=&quot;hljs-string&quot;&gt;&quot;string&quot;&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;then&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        result = result .. &lt;span class=&quot;hljs-built_in&quot;&gt;string&lt;/span&gt;.&lt;span class=&quot;hljs-built_in&quot;&gt;format&lt;/span&gt;(&lt;span class=&quot;hljs-string&quot;&gt;&quot;%q&quot;&lt;/span&gt;, param)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;hljs-keyword&quot;&gt;elseif&lt;/span&gt; t == &lt;span class=&quot;hljs-string&quot;&gt;&quot;table&quot;&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;then&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        result = result .. &lt;span class=&quot;hljs-string&quot;&gt;&quot;&amp;#123;\n&quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;hljs-keyword&quot;&gt;for&lt;/span&gt; k, v &lt;span class=&quot;hljs-keyword&quot;&gt;in&lt;/span&gt; &lt;span class=&quot;hljs-built_in&quot;&gt;pairs&lt;/span&gt;(param) &lt;span class=&quot;hljs-keyword&quot;&gt;do&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            result = result .. space .. &lt;span class=&quot;hljs-string&quot;&gt;&quot;\t&quot;&lt;/span&gt; .. &lt;span class=&quot;hljs-string&quot;&gt;&quot;[&quot;&lt;/span&gt; .. serialize(k) .. &lt;span class=&quot;hljs-string&quot;&gt;&quot;] = &quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            .. serialize(v, level + &lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;) .. &lt;span class=&quot;hljs-string&quot;&gt;&quot;,\n&quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;hljs-keyword&quot;&gt;end&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;hljs-keyword&quot;&gt;local&lt;/span&gt; metatable = &lt;span class=&quot;hljs-built_in&quot;&gt;getmetatable&lt;/span&gt;(param)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt; metatable ~= &lt;span class=&quot;hljs-literal&quot;&gt;nil&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;and&lt;/span&gt; &lt;span class=&quot;hljs-built_in&quot;&gt;type&lt;/span&gt;(metatable.&lt;span class=&quot;hljs-built_in&quot;&gt;__index&lt;/span&gt;) == &lt;span class=&quot;hljs-string&quot;&gt;&quot;table&quot;&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;then&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;hljs-keyword&quot;&gt;for&lt;/span&gt; k, v &lt;span class=&quot;hljs-keyword&quot;&gt;in&lt;/span&gt; &lt;span class=&quot;hljs-built_in&quot;&gt;pairs&lt;/span&gt;(metatable.&lt;span class=&quot;hljs-built_in&quot;&gt;__index&lt;/span&gt;) &lt;span class=&quot;hljs-keyword&quot;&gt;do&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                result = result .. &lt;span class=&quot;hljs-string&quot;&gt;&quot;[&quot;&lt;/span&gt; .. serialize(k) .. &lt;span class=&quot;hljs-string&quot;&gt;&quot;] = &quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                .. serialize(metatable.&lt;span class=&quot;hljs-built_in&quot;&gt;__index&lt;/span&gt;[v], level + &lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;) .. &lt;span class=&quot;hljs-string&quot;&gt;&quot;,\n&quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;hljs-keyword&quot;&gt;end&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;hljs-keyword&quot;&gt;end&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        result = result .. space .. &lt;span class=&quot;hljs-string&quot;&gt;&quot;&amp;#125;&quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;hljs-keyword&quot;&gt;elseif&lt;/span&gt; t == &lt;span class=&quot;hljs-string&quot;&gt;&quot;nil&quot;&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;then&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;hljs-literal&quot;&gt;nil&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;hljs-keyword&quot;&gt;else&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;hljs-comment&quot;&gt;-- @warning 不支持表中的function的序列化&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;hljs-keyword&quot;&gt;end&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; result&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;end&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="lua" scheme="http://nas.lus.red/categories/lua/"/>
    
    
      <category term="lua" scheme="http://nas.lus.red/tags/lua/"/>
    
      <category term="序列化" scheme="http://nas.lus.red/tags/%E5%BA%8F%E5%88%97%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>&lt;C++性能优化&gt;读后感</title>
    <link href="http://nas.lus.red/C-%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96-%E8%AF%BB%E5%90%8E%E6%84%9F.html"/>
    <id>http://nas.lus.red/C-性能优化-读后感.html</id>
    <published>2018-12-02T17:28:02.000Z</published>
    <updated>2020-01-10T20:02:34.014Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://img.lus.red/blog/OrmPGU.png" alt="封面" style="zoom:50%;"></p><p>拜读了<code>Kurt Guntherot</code>h的<code>Optimized C++: Proven Techniques for Heightened Performance(&lt;C++性能优化指南&gt;)</code>, 除了要吐槽下作者各种强行引用各种名人名言外, 还是受益良多的. 之前对于性能优化, 比较茫然, 最多也就能说得出一些常用的优化手段, 比如不用值传递啊, vector需要reverse啊, 各种排序算法性能啊.. 总之就是杂七杂八根据没个头绪.</p><p>最大的感受就是一点: 法有尽, 而术无穷.</p><p>现在的计算机性能不断增长, 所以即使是性能优化, 也在不断的演进. 一些比如PIMPL之类, 针对于以前编译慢的优化, 在如今, 完全可以忽略不计了.对于现在的C++性能优化, 我们应该抓住其主要矛盾: 1. 算法/逻辑 2. 硬件瓶颈.</p><p>从算法逻辑的角度, 选用更好的编译器, 更好的处理逻辑, 更好的内存结构.</p><p>从硬件的角度, 处理现在最大的瓶颈—内存, 减少内存分配复制.</p><p>现在只是简单过了一遍, 对于其中的并发优化, 内存管理器优化等还是需要进一步学习. 打算后面再看下Windows/Visual Studio相关的性能分析和优化等, 重新好好做个总结.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;img src=&quot;http://img.lus.red/blog/OrmPGU.png&quot; alt=&quot;封面&quot; style=&quot;zoom:50%;&quot;&gt;&lt;/p&gt;
&lt;p&gt;拜读了&lt;code&gt;Kurt Guntherot&lt;/code&gt;h的&lt;code&gt;Optimized C++: Pro
      
    
    </summary>
    
      <category term="读书笔记" scheme="http://nas.lus.red/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="C++" scheme="http://nas.lus.red/tags/C/"/>
    
      <category term="性能优化" scheme="http://nas.lus.red/tags/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"/>
    
      <category term="阅读" scheme="http://nas.lus.red/tags/%E9%98%85%E8%AF%BB/"/>
    
  </entry>
  
  <entry>
    <title>lua的capi</title>
    <link href="http://nas.lus.red/lua%E7%9A%84capi.html"/>
    <id>http://nas.lus.red/lua的capi.html</id>
    <published>2018-11-26T01:09:13.000Z</published>
    <updated>2018-11-26T12:00:40.629Z</updated>
    
    <content type="html"><![CDATA[<h2><span id="概述">概述</span></h2><p>由于工作中需要使用lua + C++, 所以需要学习两者之间是如何交互的(CAPI),<br>看了一些网上的资料, 对于这方面的资料不是很详尽, 而且文章水平良莠不齐,<br>导致阅读后常陷入知其然不知其所以然的茫然.</p><p>所以自己整理了下相关的内容, 按照自己的理解, 从头到尾梳理了一下.</p><a id="more"></a><h2><span id="capi概述">CAPI概述</span></h2>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h2&gt;&lt;p&gt;由于工作中需要使用lua + C++, 所以需要学习两者之间是如何交互的(CAPI),&lt;br&gt;看了一些网上的资料, 对于这方面的资料不是很详尽, 而且文章水平良莠不齐,&lt;br&gt;导致阅读后常陷入知其然不知其所以然的茫然.&lt;/p&gt;
&lt;p&gt;所以自己整理了下相关的内容, 按照自己的理解, 从头到尾梳理了一下.&lt;/p&gt;
    
    </summary>
    
      <category term="lua" scheme="http://nas.lus.red/categories/lua/"/>
    
    
      <category term="lua" scheme="http://nas.lus.red/tags/lua/"/>
    
      <category term="capi" scheme="http://nas.lus.red/tags/capi/"/>
    
  </entry>
  
  <entry>
    <title>lua解析xml</title>
    <link href="http://nas.lus.red/lua%E8%A7%A3%E6%9E%90xml.html"/>
    <id>http://nas.lus.red/lua解析xml.html</id>
    <published>2018-11-26T01:02:57.000Z</published>
    <updated>2018-11-26T12:00:46.352Z</updated>
    
    <content type="html"><![CDATA[<h2><span id="概述">概述</span></h2><p>由于在工作中需要使用lua解析器xml, 所以学习了下相关的内容.<br>为了尽可能降低依赖, 所以使用纯lua写的xml解析, 避免引入其他依赖库, 徒添烦恼.<br>然后就找到了这个开源库:</p><p>由于这个库是基于lua5.1的, 所以他提供的require相关语法,<br>放在新版本上市不可用的, 所以稍微修改了一点, 以保证在5.1的后续版本还是可以使用.<br>以下为修改后的:</p><a id="more"></a><h2><span id="使用方法">使用方法</span></h2><h2><span id="更多思考">更多思考</span></h2>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h2&gt;&lt;p&gt;由于在工作中需要使用lua解析器xml, 所以学习了下相关的内容.&lt;br&gt;为了尽可能降低依赖, 所以使用纯lua写的xml解析, 避免引入其他依赖库, 徒添烦恼.&lt;br&gt;然后就找到了这个开源库:&lt;/p&gt;
&lt;p&gt;由于这个库是基于lua5.1的, 所以他提供的require相关语法,&lt;br&gt;放在新版本上市不可用的, 所以稍微修改了一点, 以保证在5.1的后续版本还是可以使用.&lt;br&gt;以下为修改后的:&lt;/p&gt;
    
    </summary>
    
      <category term="lua" scheme="http://nas.lus.red/categories/lua/"/>
    
    
      <category term="lua" scheme="http://nas.lus.red/tags/lua/"/>
    
      <category term="xml" scheme="http://nas.lus.red/tags/xml/"/>
    
  </entry>
  
  <entry>
    <title>hexo建站实录</title>
    <link href="http://nas.lus.red/hexo%E5%BB%BA%E7%AB%99%E5%AE%9E%E5%BD%95.html"/>
    <id>http://nas.lus.red/hexo建站实录.html</id>
    <published>2018-11-19T00:45:30.000Z</published>
    <updated>2018-11-26T00:58:43.413Z</updated>
    
    <content type="html"><![CDATA[<p>之前的小站用的wordpress, 主要也是为了写写东西记录下,<br>但是使用wordpress之后,就开始沉迷于各种插件, 比如七牛云图床插件啊,<br>Wordpress支持插件啊, 代码高亮插件啊…</p><p>还有从我的印象笔记摘抄笔记也特别麻烦, 因为显示的效果总不是很满意,<br>有鉴于此, 所以决定回归markdown,只关心写作内容.<br>目前主流的markdown建站, 也就hexo和jekyll.<br>因为之前用hexo搭过一个githubio,  所以还是选hexo了.<br>絮絮叨叨了这么多, 以下为建站实录:<br><a id="more"></a></p><h2><span id="安装hexo">安装hexo</span></h2><h3><span id="为文章指定标签">为文章指定标签</span></h3><h3><span id="为文章指定目录">为文章指定目录</span></h3><h3><span id="设定文章置顶">设定文章置顶</span></h3><h3><span id="文章显示阅读更多">文章显示”阅读更多”</span></h3><h3><span id="文章中的空格换行">文章中的空格/换行</span></h3><h2><span id="安装icuras主题">安装icuras主题</span></h2><h3><span id="安装icuras">安装icuras</span></h3><h3><span id="修改icuras的个人信息">修改icuras的个人信息</span></h3><h3><span id="修改icuras主题为双栏">修改icuras主题为双栏</span></h3><h3><span id="修改icuras目录的名字">修改icuras目录的名字</span></h3><h3><span id="修改icuras的显示宽度">修改icuras的显示宽度</span></h3><h3><span id="启用搜索插件">启用搜索插件</span></h3><h2><span id="在github上建立站点">在github上建立站点</span></h2><h2><span id="在vps上建立站点">在VPS上建立站点</span></h2><h2><span id="seo">SEO</span></h2><h3><span id="通用seo优化">通用SEO优化</span></h3><h3><span id="google">google</span></h3><h3><span id="baidu">baidu</span></h3>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;之前的小站用的wordpress, 主要也是为了写写东西记录下,&lt;br&gt;但是使用wordpress之后,就开始沉迷于各种插件, 比如七牛云图床插件啊,&lt;br&gt;Wordpress支持插件啊, 代码高亮插件啊…&lt;/p&gt;
&lt;p&gt;还有从我的印象笔记摘抄笔记也特别麻烦, 因为显示的效果总不是很满意,&lt;br&gt;有鉴于此, 所以决定回归markdown,只关心写作内容.&lt;br&gt;目前主流的markdown建站, 也就hexo和jekyll.&lt;br&gt;因为之前用hexo搭过一个githubio,  所以还是选hexo了.&lt;br&gt;絮絮叨叨了这么多, 以下为建站实录:&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="网站" scheme="http://nas.lus.red/categories/%E7%BD%91%E7%AB%99/"/>
    
    
      <category term="hexo" scheme="http://nas.lus.red/tags/hexo/"/>
    
      <category term="建站" scheme="http://nas.lus.red/tags/%E5%BB%BA%E7%AB%99/"/>
    
      <category term="icuras" scheme="http://nas.lus.red/tags/icuras/"/>
    
  </entry>
  
  <entry>
    <title>C#学习笔记-委托</title>
    <link href="http://nas.lus.red/C-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E5%A7%94%E6%89%98.html"/>
    <id>http://nas.lus.red/C-学习笔记-委托.html</id>
    <published>2018-11-19T00:27:32.000Z</published>
    <updated>2020-01-11T15:05:52.019Z</updated>
    
    <content type="html"><![CDATA[<h2><span id="什么是委托">什么是委托</span></h2><p>委托是C#中的一个重要的概念.<br>委托是一个对象, 它本身含有一个或者多个方法, 可以认为是一个类型安全的, 面向对象的C++函数指针.<br>是对于C++中函数指针的一种”升级”, 因为指针除了地址本身外, 并没有办法携带其他描述的信息.<br>而委托可以</p><a id="more"></a><h2><span id="一个简单的c函数指针例子">一个简单的C++函数指针例子</span></h2><figure class="highlight c++ hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">int</span>(*Calc)(<span class="hljs-keyword">int</span> x, <span class="hljs-keyword">int</span> y);</span><br><span class="line"></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">Add</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x, <span class="hljs-keyword">int</span> y)</span></span></span><br><span class="line"><span class="hljs-function"></span>&#123;</span><br><span class="line">    <span class="hljs-keyword">return</span> x + y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">Sub</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x, <span class="hljs-keyword">int</span> y)</span></span></span><br><span class="line"><span class="hljs-function"></span>&#123;</span><br><span class="line"><span class="hljs-keyword">return</span> x - y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span></span><br><span class="line"><span class="hljs-function"></span>&#123;</span><br><span class="line">Calc = Add;</span><br><span class="line"><span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; Calc(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>) &lt;&lt; <span class="hljs-built_in">std</span>::<span class="hljs-built_in">endl</span>;</span><br><span class="line">Calc = Sub;</span><br><span class="line"><span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; Calc(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>) &lt;&lt; <span class="hljs-built_in">std</span>::<span class="hljs-built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果<br><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">3</span><br><span class="line">-1</span><br></pre></td></tr></table></figure></p><p>这里就是把函数的指针作为一个参数传递, 这样就可以通过一种方法去处理多个具有相同返回值和参数类型.</p><h2><span id="c的函数指针例子">C#的函数指针例子</span></h2><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">namespace SampleDelegate</span><br><span class="line">&#123;</span><br><span class="line">    delegate int Calc(int x, int y);</span><br><span class="line"></span><br><span class="line">    class MainClass</span><br><span class="line">    &#123; </span><br><span class="line">        static int Add(int x, int y)</span><br><span class="line">        &#123;</span><br><span class="line">            return x + y;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        static int Sub(int x, int y)</span><br><span class="line">        &#123;</span><br><span class="line">            return x - y;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        public static void Main(string[] args)</span><br><span class="line">        &#123;</span><br><span class="line">            Calc calc;</span><br><span class="line">            calc = Add;</span><br><span class="line">            Console.WriteLine(calc(1, 2));</span><br><span class="line"></span><br><span class="line">            calc = Sub;</span><br><span class="line">            Console.WriteLine(calc(1, 2));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果<br><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">3</span><br><span class="line">-1</span><br></pre></td></tr></table></figure></p><p>这个结果是C++函数指针的效果是相同的.</p><h2><span id="委托的声明和创建">委托的声明和创建</span></h2><p>委托也是一种类, 所以也是一个引用.</p><p>[delegate] [返回值] [对象名] [签名]<br>delegate void Calc(int x);</p><ol><li><p>使用new来创建<br>calc = new calc(Add);</p></li><li><p>快捷语法创建<br>calc = Add; </p></li></ol><h3><span id="委托的组合">委托的组合</span></h3><p>委托实际是一个引用, 所以委托的组合其实是指向了一个新的委托.<br><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">calc1 = Add;</span><br><span class="line">calc2 = Sub;</span><br><span class="line">calc1 = calc1 + calc2;</span><br></pre></td></tr></table></figure></p><p>也可以使用+=和-=<br><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">calc += Add;</span><br><span class="line">calc += Sub;</span><br><span class="line">calc -= Add;</span><br></pre></td></tr></table></figure></p><h2><span id="委托的使用">委托的使用</span></h2><h3><span id="带参数返回值的委托">带参数/返回值的委托</span></h3><p>如果委托有返回值, 并且方法列表不止一个方法, 那么返回值就用最后一个.</p><p>如果委托有引用参数, 在调用过程中, 会将参数的新值传给下一个方法.</p><h3><span id="泛型委托">泛型委托</span></h3><p>除了使用固定的参数, 委托也支持使用泛型<br><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">namespace SampleDelegate</span><br><span class="line">&#123;</span><br><span class="line">    delegate T Calc&lt;T&gt;(T x, T y);</span><br><span class="line"></span><br><span class="line">    class MainClass</span><br><span class="line">    &#123; </span><br><span class="line">        static int Add(int x, int y)</span><br><span class="line">        &#123;</span><br><span class="line">            return x + y;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        static double Sub(double x, double y)</span><br><span class="line">        &#123;</span><br><span class="line">            return x - y;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        public static void Main(string[] args)</span><br><span class="line">        &#123;</span><br><span class="line">            Calc&lt;int&gt; calc;</span><br><span class="line">            calc = Add;</span><br><span class="line">            Console.WriteLine(calc(1, 2));</span><br><span class="line"></span><br><span class="line">            Calc&lt;double&gt; calc2;</span><br><span class="line">            calc2 = Sub;</span><br><span class="line">            Console.WriteLine(cal2(1, 2));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4><span id="actionltgt委托">Action&lt;&gt;委托</span></h4><p>Action就是系统定义的, 返回值为void的委托.</p><h4><span id="funcltgt委托">Func&lt;&gt;委托</span></h4><p>Func就是系统定义的, 带有返回值的委托, 其中最后一个是返回值.</p><p>实际上, .Net的许多重要API都大量的使用Action和Func</p><h2><span id="委托的常见使用场景">委托的常见使用场景</span></h2><h3><span id="回调">回调</span></h3><h3><span id="使用注意事项">使用注意事项</span></h3><h2><span id="委托的代码实现">委托的代码实现</span></h2><h2><span id="本文参考">本文参考</span></h2><p>&lt;C#入门视频&gt;<br>&lt;图解C#教程&gt;<br>&lt;精通C#(第6版)&gt;</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;什么是委托&quot;&gt;&lt;a href=&quot;#什么是委托&quot; class=&quot;headerlink&quot; title=&quot;什么是委托&quot;&gt;&lt;/a&gt;什么是委托&lt;/h2&gt;&lt;p&gt;委托是C#中的一个重要的概念.&lt;br&gt;委托是一个对象, 它本身含有一个或者多个方法, 可以认为是一个类型安全的, 面向对象的C++函数指针.&lt;br&gt;是对于C++中函数指针的一种”升级”, 因为指针除了地址本身外, 并没有办法携带其他描述的信息.&lt;br&gt;而委托可以&lt;/p&gt;
    
    </summary>
    
      <category term="C#" scheme="http://nas.lus.red/categories/C/"/>
    
    
      <category term="C#" scheme="http://nas.lus.red/tags/C/"/>
    
      <category term="委托" scheme="http://nas.lus.red/tags/%E5%A7%94%E6%89%98/"/>
    
  </entry>
  
  <entry>
    <title>C#学习笔记</title>
    <link href="http://nas.lus.red/CSharp%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.html"/>
    <id>http://nas.lus.red/CSharp学习笔记.html</id>
    <published>2018-11-18T14:08:14.000Z</published>
    <updated>2020-01-11T15:04:10.560Z</updated>
    
    <content type="html"><![CDATA[<h2><span id="背景描述">背景描述</span></h2><p>记录自己学习C#的学习记录</p><h2><span id="阅读和学习">阅读和学习</span></h2><h3><span id="视频">视频</span></h3><ul><li>刘铁锰 <a href="https://www.bilibili.com/video/av1422127?from=search&amp;seid=17309818711796899189" target="_blank" rel="noopener">&lt;C#语言入门详解&gt;</a></li></ul><h3><span id="读书笔记">读书笔记</span></h3><h2><span id="学习笔记">学习笔记</span></h2><ul><li><a href="C-学习笔记-委托.html">委托</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2&gt;&lt;span id=&quot;背景描述&quot;&gt;背景描述&lt;/span&gt;&lt;/h2&gt;&lt;p&gt;记录自己学习C#的学习记录&lt;/p&gt;
&lt;h2&gt;&lt;span id=&quot;阅读和学习&quot;&gt;阅读和学习&lt;/span&gt;&lt;/h2&gt;&lt;h3&gt;&lt;span id=&quot;视频&quot;&gt;视频&lt;/span&gt;&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;刘铁锰 
      
    
    </summary>
    
      <category term="C#" scheme="http://nas.lus.red/categories/C/"/>
    
    
      <category term="C#" scheme="http://nas.lus.red/tags/C/"/>
    
      <category term="笔记" scheme="http://nas.lus.red/tags/%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
</feed>
