<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>lusipad的博客</title>
  
  <subtitle>Talk is cheap, show me the code.</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://nas.lus.red/"/>
  <updated>2020-02-26T13:22:46.252Z</updated>
  <id>http://nas.lus.red/</id>
  
  <author>
    <name>lusipad</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>&lt;平衡记分卡&gt;学习笔记</title>
    <link href="http://nas.lus.red/%E5%B9%B3%E8%A1%A1%E8%AE%B0%E5%88%86%E5%8D%A1-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.html"/>
    <id>http://nas.lus.red/平衡记分卡-学习笔记.html</id>
    <published>2020-02-26T13:04:40.000Z</published>
    <updated>2020-02-26T13:22:46.252Z</updated>
    
    <content type="html"><![CDATA[<p>因为排年度计划需要, 所以学习了下平衡记分卡, 以及其如何应用.</p><p>从我粗浅的认知来看, 平衡平衡记分卡 就是一种 战略管理 + KPI的组合工具, 通过因果关系将逐层分解并联系起来, 和目前热门的OKR相比, 平衡记分卡时间周期更长, 容易变味成KPI天坑的可能. 其实我个人还是挺喜欢OKR的, 但是自觉才疏学浅, 还是无法能够带领团队去做好, 或许可以尝试一番?</p><a id="more"></a><p><img src="http://img.lus.red/blog/平衡计分卡.png" alt="平衡记分卡思维导图"></p><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
    
    <summary type="html">
    
      &lt;p&gt;因为排年度计划需要, 所以学习了下平衡记分卡, 以及其如何应用.&lt;/p&gt;
&lt;p&gt;从我粗浅的认知来看, 平衡平衡记分卡 就是一种 战略管理 + KPI的组合工具, 通过因果关系将逐层分解并联系起来, 和目前热门的OKR相比, 平衡记分卡时间周期更长, 容易变味成KPI天坑的可能. 其实我个人还是挺喜欢OKR的, 但是自觉才疏学浅, 还是无法能够带领团队去做好, 或许可以尝试一番?&lt;/p&gt;
    
    </summary>
    
      <category term="读书笔记" scheme="http://nas.lus.red/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="平衡记分卡" scheme="http://nas.lus.red/tags/%E5%B9%B3%E8%A1%A1%E8%AE%B0%E5%88%86%E5%8D%A1/"/>
    
      <category term="管理" scheme="http://nas.lus.red/tags/%E7%AE%A1%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>《代码整洁之道》读书笔记</title>
    <link href="http://nas.lus.red/%E3%80%8A%E4%BB%A3%E7%A0%81%E6%95%B4%E6%B4%81%E4%B9%8B%E9%81%93%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0.html"/>
    <id>http://nas.lus.red/《代码整洁之道》读书笔记.html</id>
    <published>2020-02-23T13:15:59.000Z</published>
    <updated>2020-02-23T13:28:18.244Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">主观评分: 9.5</span><br><span class="line">阅读时间: 8h(粗读)</span><br><span class="line">一句话点评: 从初级程序员升级的必备书籍.</span><br></pre></td></tr></table></figure><p><img src="http://img.lus.red/blog/wth6gB.png" alt="封面"></p><a id="more"></a><p>发现还是使用思维导图更加适合作为书的笔记, 所以打算以后所有的学习笔记, 都改成思维导图的形式.</p><p>当你从初级程序员往上升级的时候, 这本书绝对会让你醍醐灌顶. 因为不使用 Java, 所以书的后几章没怎么看, 但是前几章真的是看了好几遍, 特别喜欢. “糟糕的代码”引入混乱, 而你则对此毫无办法, 只有再挖一个新的坑, 周而复始.</p><p>而作者抽丝剥茧, 一点点的深入, 把SOLID, 编码规范, TDD等思想都揉碎了, 然后在一个个章节中, 一个个案例中再重新组合起来.</p><p><img src="http://img.lus.red/blog/代码整洁之道.png" alt="思维导图"></p><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
    
    <summary type="html">
    
      &lt;figure class=&quot;highlight plain hljs&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;主观评分: 9.5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;阅读时间: 8h(粗读)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;一句话点评: 从初级程序员升级的必备书籍.&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;&lt;img src=&quot;http://img.lus.red/blog/wth6gB.png&quot; alt=&quot;封面&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="读书笔记" scheme="http://nas.lus.red/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="代码整洁之道" scheme="http://nas.lus.red/tags/%E4%BB%A3%E7%A0%81%E6%95%B4%E6%B4%81%E4%B9%8B%E9%81%93/"/>
    
      <category term="读书笔记" scheme="http://nas.lus.red/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
      <category term="软件工程" scheme="http://nas.lus.red/tags/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://nas.lus.red/Effective-C-%E7%AC%AC%E4%B8%89%E7%89%88-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0.html"/>
    <id>http://nas.lus.red/Effective-C-第三版-读书笔记.html</id>
    <published>2020-01-26T13:48:11.000Z</published>
    <updated>2020-02-07T10:31:11.772Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">主观评分: 9.5</span><br><span class="line">阅读时间: 24h(粗读)</span><br><span class="line">一句话点评: C++的第二本书.</span><br></pre></td></tr></table></figure><p>书中的忠告分为两类: <strong>一般性的设计策略</strong>, 以及带有具体细节的<strong>特定语言特性</strong>. 设计上的讨论集中于”如何在两个不同做法中择一完成某项任务.”</p><h2><span id="01-视c为一个语言联邦">01 视C++为一个语言联邦</span></h2><p>C++是个多重范型编程语言, procedural<strong>, </strong>object-oriented, generic, metaprogramming. </p><p><strong>C</strong>: block, statements, preprocessor, build-in data types, arrays, pointers</p><p><strong>Object-Oriented C++</strong>: classes, encapsulation(封装), inheritance(继承), polymorphism(多态)</p><p><strong>Template C++</strong></p><p><strong>STL</strong>: containers, iterators, alogrithms, function object.</p><p>C++高效编程守则视状况而变化, 取决于你使用C++的那一部分.</p><h2><span id="02-尽量以const-enum-inline替换define">02 尽量以const, enum, inline替换#define</span></h2><p>宁可以编译器替换预处理器.</p><p>对于单纯常量, 最好以const对象或enums替换#defines, 对于形似函数的宏, 最好改用inline函数替换#defines.</p><p><strong>对于C11, 你可以用constexpr来代替宏表达式</strong></p><a id="more"></a><h2><span id="03-尽可能使用const">03 尽可能使用const</span></h2><p>关键字const出现在星号左边, 表示被指物是常量; 如果出现在星号右边, 表示指针本身是常量; 如果出现在星号两边, 表示被指物和指针两者都是常量.</p><p>如果你希望迭代器所指的东西不可改动, 你需要的是const_iterator.</p><p>许多人漠视一件事实: 两个成员函数如果只是常量性不同, 可以被重载. 这样就会引入一个问题: <strong>成员函数如果是const意味着什么? 这里有两个概念: bitwise constness 和 logical constness.</strong></p><p>bitwise const: 成员函数只有在不更改对象之任何成员变量(static除外)时才是const. 不幸的是许多成员函数虽然不具备const性质却能通过bitwise测试, 如:更改了”指针所指物”.</p><p>logial constness: 一个const成员函数可以修改它所处理的对象内的某些bits, 但只有在客户端侦测不出的情况下才得如此.</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">将某些东西声明为const可帮助编译器监测出错误用法.</span><br><span class="line"></span><br><span class="line">编译器强制实施bitwise constness, 但是你编写程序时应该使用&quot;概念上的常量性&quot;.</span><br><span class="line"></span><br><span class="line">当const和non-cost成员函数有着等价实现时, 令non-const版本调用const版本可避免代码重复.</span><br></pre></td></tr></table></figure><h2><span id="04-确定对象被使用前已先被初始化">04 确定对象被使用前已先被初始化</span></h2><p>对象的成员变量的初始化动作发生在进入构造函数本体之前, 在构造函数内, 都不是初始化, 而是<strong>被赋值</strong>.所以构造函数一个较佳的写法是, 使用所谓的成员初始化列表来替换赋值函数.</p><p>C++有着十分固定的成员初始化顺序, base classes更早于其derived classses被初始化, 而class的成员变量总是以其声明次序被初始化.</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">为内置型对象进行手工初始化, 因为C++不保证初始化他们.</span><br><span class="line"></span><br><span class="line">构造函数最好使用成员初始列表, 而不是在构造函数本体内使用赋值操作. 初始值列出的成员变量, 其排列次序应该与他们在class中的声明次序相同.</span><br><span class="line"></span><br><span class="line">为免除跨编译单元之间初始化次序问题, 请以local static对象替换non-local static对象.</span><br></pre></td></tr></table></figure><h2><span id="05-了解c默默调用了哪些函数">05 了解C++默默调用了哪些函数</span></h2><p>如果你自己没声明, 编译器就会为他声明一个copy构造函数, 一个copy assignment操作符和一个构造函数. 如果你没有声明任何构造函数, 编译器也会为你声明一个default构造函数, 所有这些函数都是public且inline的.</p><h2><span id="06-若不想使用编译器自动生成的函数-就应该明确拒绝">06 若不想使用编译器自动生成的函数, 就应该明确拒绝</span></h2><p>声明一个成员函数, 阻止编译器创建, 并且令这些函数为private.</p><h2><span id="07-为多态基类声明virtual析构函数">07 为多态基类声明virtual析构函数</span></h2><p>当class不被当做base class, 令其析构函数为virtual往往是个坏主意.</p><p>想要实现virtual函数, 对象必须携带某些信息, 主要用来在运行期决定哪一个virtual函数该被调用, 这些信息通常由一个所谓的vptr(virtual table pointer)指针指出, 其指向一个由函数指针构成的table, 名为vtbl(virtual talbe), 每一个带有virtual函数的class都有一个对应的vtbl, 当对象调用某一个virtual函数, 实际被调用的函数取决于该对象的vptr所指的那个vtbl, 由编译器在其中寻找适当的函数指针.</p><p>class内含virtual函数, 其对象的体积会增加(一个vptr也就是一个字节), 也不再和其他语言内的相同声明有着一样的结构, 不再可能把他传递至其他语言缩写的函数, 除非你明确补偿vptr.</p><p>不要尝试着继承一个标准容器或者其他任何带有non-virtual析构函数的class.</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">polymorphic(带有多态性质的)base classes应该声明一个virtual析构函数, 如果class带有任何virtual函数, 他就应该拥有一个virtual析构函数.</span><br><span class="line"></span><br><span class="line">classes的设计目的如果不是作为base classes使用, 或不是为了具备多态性, 就不应该声明virtual析构函数.</span><br></pre></td></tr></table></figure><h2><span id="08-别让异常逃离析构函数">08 别让异常逃离析构函数</span></h2><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">析构函数绝对不要抛出异常</span><br><span class="line"></span><br><span class="line">如果客户需要对某个操作函数运行期间抛出的异常做出反应, 那么classes应该提供一个普通函数(而非在析构函数中)执行该操作</span><br></pre></td></tr></table></figure><h2><span id="09-绝不在构造和析构过程中调用virtual函数">09 绝不在构造和析构过程中调用virtual函数</span></h2><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">在构造和析构函数中不要调用virtual函数, 因为这类调用从不下降到derived class</span><br></pre></td></tr></table></figure><h2><span id="10-令operator-返回一个reference-to-this">10 令operator= 返回一个reference to *this</span></h2><h2><span id="11-在operator中处理自我赋值">11 在operator=中处理”自我赋值”</span></h2><p>传统做法是由operator=最前面一个”证同测试”达到自我赋值的校验目的.</p><p>如果你很关心效率, 可以把”证同测试”再次放回函数起始处, 然而这样做之前先问问自己, 你估计”自我赋值”的发生频率有多高? 因为这项测试也需要成本, 他会使代码变大一点, 并导入一个新的控制流分支, 而两者都会降低执行速度.</p><p>自我赋值的一个替代方案是, 使用所谓的copy and swap技术.</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">请确保对象自我赋值时operator=有良好行为, 其中技术包括比较&quot;来源对象&quot;和&quot;目标对象&quot;的地址, 精心周到的语句顺序, 以及copy-and-swap.</span><br><span class="line"></span><br><span class="line">确定任何函数如果操作一个以上的对象, 而其中多个对象是同一个对象时, 其行为仍然正确.</span><br></pre></td></tr></table></figure><h2><span id="12-复制对象时勿忘其每一个成分">12 复制对象时勿忘其每一个成分</span></h2><p>当你便携一个copying函数, 请确保:</p><p>(1) 复制所有local成员变量</p><p>(2) 调用所有base classes内适当的copying函数</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Copying函数应该确保复制&quot;对象内的所有成员变量&quot;及&quot;所有base class成分&quot;.</span><br><span class="line"></span><br><span class="line">不要尝试以某个copying函数实现另一个copying函数, 应将共同机能放进第三个函数, 而是用两个coping函数共同调用.</span><br></pre></td></tr></table></figure><h2><span id="13-以对象管理资源">13 以对象管理资源</span></h2><p>把资源放进对象内, 我们便可以依赖C++的”析构函数自动调用机制”来确保资源被释放.</p><p>(1) 获得资源后立刻放进管理对象</p><p>(2) 管理对象运用构造函数确保资源被释放</p><p>未来预防如果多个auto_ptr指向同一个对象的问题, auto_ptr有一个不寻常的性质: 如果通过copy构造函数或copy操作符复制他们, 会变成null, 而复制所得的指针将取得资源的唯一拥有权.</p><p>auto_ptr的替代方案是”引用技术型智慧指针”, 无法打破环状引用.</p><p>并没有特别针对”C++动态分配数组”而设计的类似auto_ptr或trl::share_ptr那样的东西, 那是因为vector和string集合总是可以取代动态分配而得的数组.</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">为防止资源泄露, 请使用RAII对象, 他们在构造函数中获得资源并在析构函数中释放资源.</span><br><span class="line"></span><br><span class="line">两个常被使用的RAII classes分别是trl::shared_ptr和auto_ptr.</span><br></pre></td></tr></table></figure><h2><span id="14-在资源管理类中小心copying行为">14 在资源管理类中小心copying行为</span></h2><p>当一个RAII对象被复制, 会发生什么</p><p>(1) 禁止复制</p><p>(2) 对底层资源祭出”引用计数法”</p><p>(3) 复制底部资源</p><p>(4) 转移底部资源的拥有权</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">复制RAII对象必须一并复制它所管理的资源, 所以资源的copying行为决定RAII对象的copying行为.</span><br><span class="line"></span><br><span class="line">普遍而常见的RAII classes copying行为是: 抑制copying, 施行引用计数法, 不过其他行为也都可能被实现.</span><br></pre></td></tr></table></figure><h2><span id="15-在资源管理类中提供对原始资源的访问">15 在资源管理类中提供对原始资源的访问</span></h2><p>是否提供一个显式转换函数(比如get成员函数), 将RAII classes转换为其底层资源, 或是应该提供隐式转换, 答案主要取决于RAII classes被设计执行的特定工作, 以及它被使用的情况. 最佳设计很可能是18: 让接口容易被正确使用, 不易被误用.</p><p>你的内心也可能认为, RAII classes内的那个返回原始资源的函数, 与封装发生矛盾, RAII classes并不是为了封装某物而存在; 他们存在是为了确保一个特殊行为: 资源释放会发生.</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">APIs往往要求访问原始资源, 所以每一个RAII class应该提供一个取得其所管理之资源的办法</span><br><span class="line"></span><br><span class="line">对原始资源的访问可能经由显示转换或隐式转换, 一般而言显式转换比较安全, 但隐式转换对客户比较方便</span><br></pre></td></tr></table></figure><h2><span id="16-成对使用new和delete时要采用相同形式">16 成对使用new和delete时要采用相同形式</span></h2><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">如果你在new表达式中使用[], 必须在相应的delete表达式中也使用[]</span><br></pre></td></tr></table></figure><h2><span id="17-以独立语句将newed对象置入智能指针">17 以独立语句将newed对象置入智能指针</span></h2><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">一旦抛出异常, 有可能导致难以察觉的资源泄露.</span><br></pre></td></tr></table></figure><h2><span id="18-让接口容易被正确使用-不易被误用">18 让接口容易被正确使用, 不易被误用</span></h2><p>提供行为一致的接口.</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">好的接口很容易被正确使用, 不容易被误用.</span><br><span class="line"></span><br><span class="line">促进正确使用的办法包括接口的一致性,以及内置类型的行为兼容</span><br><span class="line"></span><br><span class="line">组织无用的办法包括尽力新类型, 限制类型上的操作, 束缚对象值, 以及消除客户的资源管理责任.</span><br><span class="line"></span><br><span class="line">shared_ptr支持定制型删除器, 可以预防DLL问题.</span><br></pre></td></tr></table></figure><h2><span id="19-设计class犹如设计type">19 设计class犹如设计type</span></h2><p>新type的对象应该如何被创建和销毁?</p><p>对象的初始化和对象的赋值该有什么样的差别?</p><p>新type的对象如果被pass by value, 意味着什么?</p><p>什么是type的合法性?</p><p>你的心type需要配合某个继承图系吗?</p><p>你的新type需要什么样的转换?</p><p>什么样的操作符和函数对此新type而言是合理的?</p><p>什么样的标准函数应该驳回?</p><p>谁该取用新type的成员?</p><p>什么是新type的未声明接口?</p><p>你的新type有多么一般化?</p><p>你真的需要一个新type吗?</p><h2><span id="20-宁以pass-by-reference-to-const替换pass-by-value">20 宁以pass by reference to const替换pass by value</span></h2><p>以by reference方式传递参数也可以避免对象切割问题, 当一个derived class对象以by value方式传递并被视为一个base class对象, base class的copy构造函数会被调用, 而造成此对象的行为像个derived class对象的那些特化性质全被切割掉了, 仅留下一个base class对象.</p><p>pass by reference通常意味着真正传递的是指针, 如果你有个对象属于内置类型, pass by value往往比pass by reference的效率高些. 这个忠告也适用于STL的迭代器和函数对象.</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">尽量以pass by reference to const替代pass by value, 前者通常比较高效, 并可避免切割问题.</span><br><span class="line"></span><br><span class="line">以上规则并不适用于内置类型, 以及STL的迭代器和函数对象.</span><br></pre></td></tr></table></figure><h2><span id="21-必须返回对象时-别妄想返回其reference">21 必须返回对象时, 别妄想返回其reference</span></h2><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">不要返回pointer或reference指向一个local stack对象, 或返回reference指向一个heap-allocated对象, 或返回pointer或reference指向一个local static对象而又可能同时需要多个这样的对象.</span><br></pre></td></tr></table></figure><h2><span id="22-将成员变量声明为private">22 将成员变量声明为private</span></h2><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">将成员变量声明为private, 这可以赋予客户访问数据的一致性, 可细微划分访问控制, 允诺约束条件或者保证, 并提供class作者以充分的实现弹性.</span><br><span class="line"></span><br><span class="line">protected并不比public更具封装性.</span><br></pre></td></tr></table></figure><h2><span id="23-宁以non-member-non-friend替换member函数">23 宁以non-member, non-friend替换member函数</span></h2><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">这样做可以增加封装性, 包裹弹性和技能扩充性.</span><br></pre></td></tr></table></figure><h2><span id="24-若所有参会皆需要类型转换-请为此提供non-member函数">24 若所有参会皆需要类型转换, 请为此提供non-member函数</span></h2><h2><span id="25-考虑写出一个一个不抛异常的swap函数">25 考虑写出一个一个不抛异常的swap函数</span></h2><p>这个是异常安全性编程的基础</p><h2><span id="26-尽可能延后变量定义式的出现时间">26 尽可能延后变量定义式的出现时间</span></h2><p>虽然延后在大多数场景下都是适用的, 但是会破坏整个编码风格, 另外循环这个问题还是没有解决, 只能根据构造+析构和赋值哪个成本更高来选择.</p><h2><span id="27-尽量少做转型动作">27 尽量少做转型动作</span></h2><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">如果可以, 尽量避免转型</span><br><span class="line"></span><br><span class="line">如果转型是必要的, 是这将它隐藏在某个函数背后, 客户端可以随意调用该函数, 而不需要将转型放进他们自己的代码里.</span><br><span class="line"></span><br><span class="line">宁可以使用C++-Stypple, 而不是旧式转型.</span><br></pre></td></tr></table></figure><h2><span id="28-尽量避免返回handles指向对象内部成分">28 尽量避免返回handles指向对象内部成分</span></h2><h2><span id="29-为异常安全而努力是值得的">29 为异常安全而努力是值得的</span></h2><p>异常抛出时, 带有异常安全处理的函数会:</p><ul><li><p>不泄露任何资源</p></li><li><p>不允许数据破坏</p></li><li><p>基本承诺 (程序是在有效状态下)</p></li><li><p>强烈保证 (程序状态不改变)</p></li><li><p>nothrow保证</p><p><strong>这里后续还要延伸下</strong></p></li></ul><h2><span id="30-透彻了解inlining的里里外外">30 透彻了解inlining的里里外外</span></h2><p>inlining通常是编译期行为.</p><p>inline是个申请, 编译器可以忽略.</p><p>程序库设计者必须评估 将函数声明为inline的冲击: inline函数无法随着程序库的升级而升级. 一旦设计者修改了inline函数, 所有用到的客户端都必须重新编译.</p><h2><span id="31-将文件夹的编译依存关系降至最低">31 将文件夹的编译依存关系降至最低</span></h2><p>当你对某个class的private修改, 你会发现build时要重新编译和链接, </p><p>问题出现在C++并没有把 从接口从实现分离做得很好, class的定义中不仅描述了接口, 还有实现细节. 导致定义和其包含文件存在了编译依存关系.</p><p>C++为什么不这么做? 因为<strong>正确的前置声明很复杂</strong>, 因为涉及额外的templates. 另外一点困难是, 编译器必须在编译期间知道对象的大小.</p><p>在我们的代码中, 这个也是Pipeline会被分成Pipeline和PipelineImp的原因.</p><p>如果使用object reference或pointer可以完成任务, 就不用使用object.</p><p>如果能够, 尽量以class声明替换class定义式.</p><p>为声明式和定义式提供不同的头文件.</p><h2><span id="32-确定你的pubic继承模出is-a关系">32 确定你的pubic继承模出is-a关系</span></h2><p><strong>正方形和长方形的类如何设计? 好好思考下这个问题</strong></p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public继承意味着is-a, 适用于base classes身上的每一件事情一定也适用于derived classes身上, 因为每一个derived class对象也都是一个base class对象.</span><br></pre></td></tr></table></figure><h2><span id="33-避免遮掩继承而来的名称">33 避免遮掩继承而来的名称</span></h2><h2><span id="34-区分接口继承和实现继承">34 区分接口继承和实现继承</span></h2><p>这一章后面还要回头再总结下.</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">接口继承和实现继承不同, 在public继承之下, derived classes总是继承base class的接口.</span><br><span class="line"></span><br><span class="line">pure virtual函数只具体指定接口继承.</span><br><span class="line"></span><br><span class="line">impure virtual函数具体指定接口继承及缺省实现继承.</span><br><span class="line"></span><br><span class="line">non-virtual 函数具体指定接口继承函数以及强制性实现继承.</span><br></pre></td></tr></table></figure><h2><span id="35-考虑virtual函数以外的其他选择">35 考虑virtual函数以外的其他选择</span></h2><p>这里引入了思想流派, 主张virtual函数应该几乎总是private, 较好的设计师保留public函数, 但让它成为non-virtual, 并且调用一个private virtual函数.</p><p>这个有点类似于将DoBefore, DoAfter变成了一个过程函数.</p><p>作者在书中提出了集中方式, 比如Strategy模式+tr1:function, 古典的strategy模式的, 但是看上去都不是很modern, 所以这里记录下, 可能要拓展, 但是总体思想就是不要迷信”virtual”.</p><h2><span id="36-绝不重新定义继承而来的non-virtual函数">36 绝不重新定义继承而来的non-virtual函数</span></h2><h2><span id="37-绝不重新定义继承而来的缺省参数值">37 绝不重新定义继承而来的缺省参数值</span></h2><h2><span id="38-通过符合塑模出has-a或根据某事物实现出">38 通过符合塑模出has-a或”根据某事物实现出”</span></h2><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">复合的意义和public继承完全不同</span><br><span class="line"></span><br><span class="line">在应用域, 复合意味着has-a, 在实现域, 复合意味着根据某事物实现出.</span><br></pre></td></tr></table></figure><h2><span id="39-明智而谨慎地使用private继承">39 明智而谨慎地使用private继承</span></h2><p>private继承意味着根据某物实现出, 这个和我们的期望并不同, 而且可以用复合来代替. 不过private继承可能是empty base的一个最优解.</p><h2><span id="40-明智而谨慎地使用多重继承">40 明智而谨慎地使用多重继承</span></h2><h2><span id="41-了解隐式接口和编译器多态">41 了解隐式接口和编译器多态</span></h2><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">class和tempate都支持interfaces和polymorphism</span><br><span class="line"></span><br><span class="line">对classes而言, interface是explict, 以function signature为中心, polymorphism则是以virtual函数实现, 发生在运行时.</span><br><span class="line"></span><br><span class="line">对template参数而言, 接口是implict, 基于有效表达式, polymmorphism则是通过template具现化和function overloading resolution发生于编译器.</span><br></pre></td></tr></table></figure><h2><span id="42-了解typename的双重意义">42 了解typename的双重意义</span></h2><p>因为C++其实并不知道你所定义的名称, 比如说classname C中C的含义, 而通过关键字typename, 则是可以显示指定.</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">声明template参数时, 前缀关键字class和typename可互换.</span><br><span class="line"></span><br><span class="line">请使用关键字typename标志嵌套从属类型名称, 但不得在base class lists或member initialization list内以它作为base class的修饰符</span><br></pre></td></tr></table></figure><h2><span id="43-学习处理模板化基类内的名称">43 学习处理模板化基类内的名称</span></h2><h2><span id="44-将与参数无关的代码抽离template">44 将与参数无关的代码抽离template</span></h2><h2><span id="45-运用成员函数模板接受所有兼容类型">45 运用成员函数模板接受所有兼容类型</span></h2><h2><span id="46-需要类型转换时请为模板定义非成员函数">46 需要类型转换时请为模板定义非成员函数</span></h2><h2><span id="47-清使用triaits-classes表现类型信息">47 清使用triaits classes表现类型信息</span></h2><h2><span id="48-认识template元编程">48 认识template元编程</span></h2><p>目前template用的少, 这个需要结合实践, 光看书效果不佳, 暂时记录下, 后续再补充, 并且感觉作者本书中对于元编程的例子都比较粗浅, 还要结合后续的看下.</p><h2><span id="49-了解new-handler的行为">49 了解new-handler的行为</span></h2><p>这里的内容书上写得有点简单, 需要深入下, 不过解释了郑博之前说的”new出来的指针不可能为空”这个问题.</p><h2><span id="50-了解new和delete的合理替换时机">50 了解new和delete的合理替换时机</span></h2><p>作者列举了一些替换new和delete的场景:</p><ul><li>为了检测错误</li><li>为了手机动态分配内存之使用统计信息</li><li>为了增加分配和归还的速度</li><li>为了降低缺省内存管理器带来的空间额外开销</li><li>为了弥补缺省分配器中的非最佳对齐位</li><li>为了将相关对象成簇集中</li><li>为了获得非传统的行为</li></ul><h2><span id="51-编写new和delete时需固守常规">51 编写new和delete时需固守常规</span></h2><p>这里提到了两个细节: 内存分配失败和空指针的删除, 但是我认为实际场景下不是这么简单的, 比如说我们的内存池, 其实还有很多其他的约定, 比如异常, 比如继承等等, 这些也是目前欠考虑的, 后续需要在设计内存池上继续下更多的功夫.</p><h2><span id="52-写了placement-new也要写placement-delete">52 写了placement new也要写placement delete</span></h2><h2><span id="53-不雅轻易忽略编译器的警告">53 不雅轻易忽略编译器的警告</span></h2><h2><span id="54-让自己熟悉包括tr1在内的标准程序库">54 让自己熟悉包括TR1在内的标准程序库</span></h2><p>显然这条已经过时了, 在一项调查中, C11已经成为了C++的主要使用标准, 除此以外还有C19, 出乎人的意料.</p><h2><span id="55-让自己熟悉boost">55 让自己熟悉Boost</span></h2><h2><span id="总结">总结</span></h2><p>纸上得来终觉浅, 绝知此事要躬行, 看完了<effective c++="">给人的感觉是一种破碎的感觉, 每一个点都比较独立, 所以后续的计划是(1) 阅读<more effective="" c++="">和<effective modern="" c++="">, (2) 重新梳理下思维导图结构, 并且考虑在三本书阅读完后, 是否可以由自己重新阐述所有的观点.</effective></more></effective></p><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
    
    <summary type="html">
    
      &lt;figure class=&quot;highlight plain hljs&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;主观评分: 9.5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;阅读时间: 24h(粗读)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;一句话点评: C++的第二本书.&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;书中的忠告分为两类: &lt;strong&gt;一般性的设计策略&lt;/strong&gt;, 以及带有具体细节的&lt;strong&gt;特定语言特性&lt;/strong&gt;. 设计上的讨论集中于”如何在两个不同做法中择一完成某项任务.”&lt;/p&gt;
&lt;h2 id=&quot;01-视C-为一个语言联邦&quot;&gt;&lt;a href=&quot;#01-视C-为一个语言联邦&quot; class=&quot;headerlink&quot; title=&quot;01 视C++为一个语言联邦&quot;&gt;&lt;/a&gt;01 视C++为一个语言联邦&lt;/h2&gt;&lt;p&gt;C++是个多重范型编程语言, procedural&lt;strong&gt;, &lt;/strong&gt;object-oriented, generic, metaprogramming. &lt;/p&gt;
&lt;p&gt;&lt;strong&gt;C&lt;/strong&gt;: block, statements, preprocessor, build-in data types, arrays, pointers&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Object-Oriented C++&lt;/strong&gt;: classes, encapsulation(封装), inheritance(继承), polymorphism(多态)&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Template C++&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;STL&lt;/strong&gt;: containers, iterators, alogrithms, function object.&lt;/p&gt;
&lt;p&gt;C++高效编程守则视状况而变化, 取决于你使用C++的那一部分.&lt;/p&gt;
&lt;h2 id=&quot;02-尽量以const-enum-inline替换-define&quot;&gt;&lt;a href=&quot;#02-尽量以const-enum-inline替换-define&quot; class=&quot;headerlink&quot; title=&quot;02 尽量以const, enum, inline替换#define&quot;&gt;&lt;/a&gt;02 尽量以const, enum, inline替换#define&lt;/h2&gt;&lt;p&gt;宁可以编译器替换预处理器.&lt;/p&gt;
&lt;p&gt;对于单纯常量, 最好以const对象或enums替换#defines, 对于形似函数的宏, 最好改用inline函数替换#defines.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;对于C11, 你可以用constexpr来代替宏表达式&lt;/strong&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="读书笔记" scheme="http://nas.lus.red/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="C++" scheme="http://nas.lus.red/tags/C/"/>
    
      <category term="读书笔记" scheme="http://nas.lus.red/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>加油武汉</title>
    <link href="http://nas.lus.red/%E5%8A%A0%E6%B2%B9%E6%AD%A6%E6%B1%89.html"/>
    <id>http://nas.lus.red/加油武汉.html</id>
    <published>2020-01-23T06:33:08.000Z</published>
    <updated>2020-01-23T06:34:00.414Z</updated>
    
    <content type="html"><![CDATA[<h1><span id="加油武汉">加油武汉!</span></h1><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1&gt;&lt;span id=&quot;加油武汉&quot;&gt;加油武汉!&lt;/span&gt;&lt;/h1&gt;&lt;script type=&quot;text/javascript&quot; src=&quot;https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js&quot;&gt;&lt;/script&gt;
      
    
    </summary>
    
      <category term="杂记" scheme="http://nas.lus.red/categories/%E6%9D%82%E8%AE%B0/"/>
    
    
  </entry>
  
  <entry>
    <title>&lt;不测的秘密-精准测试之路&gt;读后感</title>
    <link href="http://nas.lus.red/%E4%B8%8D%E6%B5%8B%E7%9A%84%E7%A7%98%E5%AF%86-%E7%B2%BE%E5%87%86%E6%B5%8B%E8%AF%95%E4%B9%8B%E8%B7%AF-%E8%AF%BB%E5%90%8E%E6%84%9F.html"/>
    <id>http://nas.lus.red/不测的秘密-精准测试之路-读后感.html</id>
    <published>2020-01-22T13:47:06.000Z</published>
    <updated>2020-01-22T14:20:16.750Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://img.lus.red/blog/CSjfFY.png" alt="封面" style="zoom:50%;"></p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">主观评分: 8.5</span><br><span class="line">阅读时间: 2h(粗读)</span><br><span class="line">一句话点评: 通过分析二进制,区分分支覆盖,并且辅以推荐系统,来达到精确测试.</span><br></pre></td></tr></table></figure><a id="more"></a><p>发现测试那边人手一本&lt;不测的秘密–精准测试之路&gt;, 借阅了以后大概的粗略看了下.</p><p>目前我们测试也发现了这样一个问题, 因为测试和开发是分离的, 所以开发说只修改了一行代码, 测试怎么确保你所修改的影响范围呢? 大家都知道墨菲定律, 所以这个时候看似最靠谱的策略就是<strong>全部重测</strong>…</p><p>本书的作者就是通过一个个小故事, 来讲述怎么样去精准的测试, 只测试受影响的. 具体的做法就是通过分析二进制文件, 根据调用链来确定对测试用例的影响, 后续辅以推荐系统, 做到自动推荐受影响的测试范围.</p><p>但是腾讯的书的通病, 书里提到的东西… 都是不开源的…</p><p>上次看&lt;腾讯游戏开发&gt;就很头痛了, 讲了一堆我们做了个巴拉巴拉的东西, 思路是怎么样怎么样的.. 结果一看, 不开源的, 都是内部用的, 照着来做一个, 不知道要踩多少坑. 这个也是, 虽然没有开动, 但是肉眼可见的, 又是一个看上去很美的项目…</p><p>暂时先这样, 等后续考虑TDD的时候再想想这个是不是可以集成进去.</p><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://img.lus.red/blog/CSjfFY.png&quot; alt=&quot;封面&quot; style=&quot;zoom:50%;&quot;&gt;&lt;/p&gt;
&lt;figure class=&quot;highlight plain hljs&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;主观评分: 8.5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;阅读时间: 2h(粗读)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;一句话点评: 通过分析二进制,区分分支覆盖,并且辅以推荐系统,来达到精确测试.&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="读书笔记" scheme="http://nas.lus.red/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="读书笔记" scheme="http://nas.lus.red/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
      <category term="测试" scheme="http://nas.lus.red/tags/%E6%B5%8B%E8%AF%95/"/>
    
      <category term="精准测试" scheme="http://nas.lus.red/tags/%E7%B2%BE%E5%87%86%E6%B5%8B%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>&lt;代码精进之路--从码农到工匠&gt;读后感</title>
    <link href="http://nas.lus.red/%E4%BB%A3%E7%A0%81%E7%B2%BE%E8%BF%9B%E4%B9%8B%E8%B7%AF-%E4%BB%8E%E7%A0%81%E5%86%9C%E5%88%B0%E5%B7%A5%E5%8C%A0-%E8%AF%BB%E5%90%8E%E6%84%9F.html"/>
    <id>http://nas.lus.red/代码精进之路-从码农到工匠-读后感.html</id>
    <published>2020-01-22T12:42:05.000Z</published>
    <updated>2020-01-22T14:18:00.265Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://img.lus.red/blog/R7zJd7.png" alt="封面" style="zoom:50%;"></p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">主观评分: 9.5</span><br><span class="line">阅读时间: 6(粗读)</span><br><span class="line">一句话点评:</span><br></pre></td></tr></table></figure><a id="more"></a><p>[toc]</p><p>原本以为这本只是一本跟风之作, 因为&lt;程序员修炼之道–从小工到专家&gt;实在是太有名了, 导致后续不少书都有类似从xx到xx之类的副标题, 而且质量又良莠不齐, 特别容易引人浮躁. 但是这本书不同, 这本书可以说是今年至今为止让我最爱不释手的一本了, 忍不住想要好好精读一遍.</p><p>为什么这本书让我爱不释手?<br>因为这本书解决了好几个我心中的疑惑, 但是又不知如何去描述的问题, 等看到了相关章节, 真的有一种aha moment的感觉, 个中滋味, 如人饮水, 冷暖自知.</p><p>“愿天下没有烂代码”, 这本书以此为切入点, 首先描述了一些编程技巧和方法论, 然后从更高层次的思想指导, 来统领方法论和技巧, 特别是对于技术Leader的职责给出了切实有效的建议, 最后则是结合了一些实践, 包括他们自研的COLA架构和落地.</p><p>全书之中, 对我最有价值的部分莫过于技术Leader这个章节了. 因为我本身也是突然变成了这样一个定位, 挺迷茫自己究竟要做什么, 而作者对于技术Leader和Manager的分析, 让人恍然大悟, 作者还辅以OKR, CodeReivew, 技术规划等等一系列切实有效的技术Leader工作, 受益匪浅, 待开年后心里就有谱了.</p><p>并且这本书也可以作为一个技术目录使用, 因为很多点其实作者只是浅尝辄止, 并未有特别深入去说明, 完全可以在后续进行补充.</p><h2><span id="命名">命名</span></h2><h3><span id="有意义的命名">有意义的命名</span></h3><p>变量名应该是名词, 能够正确地描述业务, 有表达力.</p><p>函数命名要具体, 空乏的命名没有意义. 函数的命名要体现做什么, 而不是怎么做.</p><p>类分成两大类: 试题类和辅助类. 实体类承载了核心业务数据和核心业务逻辑, 其命名要充分体现业务语义, 辅助类是辅助实体类一起完成业务逻辑的, 其命名要能够通过后缀来体现功能.</p><p>包代表了一组有关系的类的集合, 起到分类组合和命名空间的作用.</p><h2><span id="规范">规范</span></h2><p>发现共通抽象和机制, 可以在很大程度上帮助我们理解复杂系统.</p><h3><span id="日志规范">日志规范</span></h3><p>Error表示不能自己恢复的错误, 需要立即被关注和解决.</p><p>Warn, 对于可预知的业务问题, 最好不要用Error输出日志, 以免污染报警系统. 例如: 参数校验不通过, 没有访问权限等<strong>业务异常</strong>, 就不应该用Error输出.</p><p>Info用于记录系统的基本运行过程和运行状态.</p><h3><span id="异常规范">异常规范</span></h3><h4><span id="异常处理">异常处理</span></h4><p>很多应用系统因为没有同意的异常处理规范, 增加了认为的复杂性:</p><p>(1) 代码中导出充斥着异常捕获的try/catch, 搞乱了代码结构, 把错误处理和正常流程混为一谈, 严重影响了代码的可读性.</p><p>(2) 异常处理不统一, 有的场景对外直接抛出异常, 有的场景对外返回错误码, 这种不一致性让服务的调用方摸不着头脑, 增加了服务的使用成本和沟通成本.</p><p>针对以上问题, 建议在业务系统中设定两个异常, 分别是业务异常和系统异常.</p><h2><span id="设计原则">设计原则</span></h2><p>SOLID.</p><p>Single Responsibility Principle. (SRP) 单一职责原则.</p><p>Open Close Principle. (OCP) 开闭原则,</p><p>Liskov Substitution Principle. (LSP) 里式替换原则.</p><p>Interface Segregation Principle. (ISP) 接口隔离原则.</p><p>Dependency Inversion Principle. (DIP) 依赖倒置原则.</p><p>Don’t Repeat Yourself. (DRY)</p><p>You Ain’t Gonna Need It.(YAGNI)</p><p>Rule Of Three. (第三次出现时, 才开始抽象化)</p><p>Keep It Simple and Stuipid. (KISS)</p><p>Principle of least astonishment. (POLA) 最小惊奇原则.</p><h2><span id="设计模式">设计模式</span></h2><p>模式不是框架, 也不是过程. 模式不是简单的”问题的解决方案”, 必须是典型问题的解决方案, 是可以让学习者举一反三的, 是理论和实践之间的中介环节. 模式具有一般性, 简单性, 重复性, 结构性, 稳定性和可操作性等特征.</p><h2><span id="技术leader的修养">技术Leader的修养</span></h2><h3><span id="技术氛围">技术氛围</span></h3><p>一个技术团队, 不管大小, 如果没有”技术味道”, 那么技术Leader负有很大的责任.</p><h4><span id="代码好坏味道">代码好坏味道</span></h4><p>周会的主持人需要给大家分享3个代码好味道和3个代码坏味道代码, 这些代码既可以是来自我们工作中的代码, 也可以是来自开源软件的源码.</p><h4><span id="技术分享">技术分享</span></h4><p>分享是倒逼我们区学习和总结的有效手段</p><h4><span id="cr周报">CR周报</span></h4><p>各种Code Review的方式都很好, 但是有一个共同的缺点, 就是很难将过程透明化.</p><p>CR周报就是要把CR的结果透明化, 通过周报的形式展现团队在一周中的CR成果, 包括团队成员的CR评论排名, 代码分支的质量情况, 以及CR中的典型案例. 这种透明化非常有价值, 既可以帮助技术Leader了解代码质量的概况, 也能极大地调用团队成员进行CR的积极性.</p><h4><span id="读书会">读书会</span></h4><p>书的范围可以放宽一点, 读书的形式可以是同读一本书, 也可以是拆书. 读书会的举办频率可以灵活一些.</p><h3><span id="目标管理">目标管理</span></h3><h3><span id="技术规划">技术规划</span></h3><p>技术规划更多的是从团队视角去看接下来要做的事情, 而目标管理师要把规划要做的事情进行拆解, 和个人目标对齐. 做好技术规划是非常重要的事情, 一个团队有没有价值, 最终还是要通过做出来的事情来体现.</p><h4><span id="当前问题">当前问题</span></h4><p>主要看团队中现在有什么迫切, 紧急的问题要解决, 有什么坑要去填.</p><h4><span id="技术领域">技术领域</span></h4><p>在常规领域中, 根据业务情况和团队情况选择一些领域和命题(比如稳定, 性能, 效率等), 并在这些命题和方向中根据优先级做判断.</p><h4><span id="业务领域">业务领域</span></h4><p>充分了解业务, 关注业务, 要分析业务数据和发展趋势, 和业务同事充分交流, 总结和抽象出业务的发展对技术会提出什么诉求, 需要技术做什么布局和建设以应对业务发展的需求.</p><h4><span id="团队特色">团队特色</span></h4><p>对比团队内外技术的异同, 最终圈定一个差异化区域.</p><h3><span id="leader和manager的区别">Leader和Manager的区别</span></h3><p>Manager是管理事务, 是控制和权威; 而Leader是领导人心, 是引领和激发.</p><p>我们不需要这么多高高在上, 指点江山的技术Manager, 而是需要更多能够真正深入系统里面, 深入代码细节, 给团队带来改变的技术Leader.</p><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://img.lus.red/blog/R7zJd7.png&quot; alt=&quot;封面&quot; style=&quot;zoom:50%;&quot;&gt;&lt;/p&gt;
&lt;figure class=&quot;highlight plain hljs&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;主观评分: 9.5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;阅读时间: 6(粗读)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;一句话点评:&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="读书笔记" scheme="http://nas.lus.red/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="读书笔记" scheme="http://nas.lus.red/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
      <category term="方法论" scheme="http://nas.lus.red/tags/%E6%96%B9%E6%B3%95%E8%AE%BA/"/>
    
      <category term="代码质量" scheme="http://nas.lus.red/tags/%E4%BB%A3%E7%A0%81%E8%B4%A8%E9%87%8F/"/>
    
  </entry>
  
  <entry>
    <title>学习路线</title>
    <link href="http://nas.lus.red/%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF.html"/>
    <id>http://nas.lus.red/学习路线.html</id>
    <published>2020-01-14T16:05:38.000Z</published>
    <updated>2020-01-14T17:02:46.889Z</updated>
    
    <content type="html"><![CDATA[<p>临近年关了, 最近的工作重心也落到了聊聊绩效和未来一年的规划, 能够感受到大家的对未来的憧憬, 也有很多迷茫和彷徨, 但是总体来说氛围还是比较向上的.</p><p>因为最近Review了不少代码, 有相当一部分是我自己不熟悉的功能, 需要花费一些精力去了解背后的逻辑, 所以愈发觉得自己还是太菜了, 想做的想学的很多, 但是如何去做好它, 可能真的需要花费一番功夫.</p><h2><span id="怎样学习">怎样学习</span></h2><p>怎么样去学习? 大多数人脑中的第一反应是看书. 看书能够提供系统性的知识, 对于个人学习还是非常有帮助的. 但是看书又往往是效率很低的, 网上有这样的说法, 虽然不能全信, 但还是有一点道理的:</p><p>只是听讲，在一个月之后就剩下5%；</p><p>只是阅读，在一个月之后就剩下10%；</p><p>只是视听，在一个月之后就剩下20%；</p><p>经常看演示，在一个月之后就剩下30%；</p><p>经常讨论，在一个月之后就剩下50%；</p><p>经常实践，在一个月之后就剩下75%；</p><p>把学到的知识教授给他人，在一个月之后能剩下90%！</p><p>教授这事儿相对而言会麻烦点, 那么我们可以选择实践!</p><h2><span id="学习什么">学习什么</span></h2><p>聊了一段时间后, 我发现OKR(目标管理)非常适合学习这个场景.</p><p>目标管理的核心是什么? 具有挑战性的积极目标 + 量化的关键结果 + 持续的反馈.</p><p>所以我就问了新人, 你的目标是什么?  “学好C#”.</p><p>那我们的目标就是学好C#, 那你怎么去衡量自己学好了C#呢?</p><p>是看完了&lt;精通C#&gt;, 看完了&lt;C#本质论&gt;还是看完了Channel9上的C#视频?</p><p>都不是, 这些只是过程, 哪怕你完成了, 也并不能证明你学好了C#.</p><p>这个时候你就应该去找关键结果, 能够用来量化你学好C#的证明.</p><p>比如说, 熟练掌握了C#的语言特性XML特性, 能够使用XML开发一个RSS订阅软件.</p><p>而且, 还要<strong>加上时间</strong>, 不要过短, 不宜过长. 两个月, 足矣.</p><p>当你能把所有的关键结果都讲清楚了, 想清楚了, 你的路子就不会歪了.</p><p>可惜我C#不行, 所以讲不出太多.</p><h2><span id="语言学习">语言学习</span></h2><p>其实语言的学习, 我个人倒是觉得最简单. 为什么? 因为目标明确.</p><p>任何一种语言, 不管你是python还是汇编, 总之离不开这样的几个过程:</p><ul><li><p>掌握语言特性. 这里基本上就是语法啊, 特性啊, 常用库之类, 看本身复杂度, 短则几天, 长则数月.</p></li><li><p>熟练应用. 这个阶段可能会持续很长, 并且每个人的环境, 压力不同, 所以成长速度不一定, 在这个阶段, 会开始逐渐深入, 当然更多人可能会因为没有持续的输入或者输出, 出现了”瓶颈”.</p></li><li>设计. 这个阶段就是俗称的”造轮子”, 自己写库, 自己深挖编译器… 不一而足.</li></ul><p>就以我熟悉的C++而言,</p><p>第一阶段, 掌握语言特性, <essential c++="">了解编程范式, &lt;C++ Primer&gt;学习语法和STL, 配合一定量的练习, 你就已经入门, 可以干活了.</essential></p><p>第二阶段, 一方面是随着代码的越写越多, 你需要总结经验和继续深入, 这个时候你可能就要开始看<effective c++="">, <more effective="" c++="">, &lt;深入探索C++对象模型&gt;, &lt;STL源码剖析&gt;, &lt;STL标准库&gt;… 另一方面则是广度, 你开始接触更多设计的, 架构的方法和思想, 所以&lt;设计模式 可复用面向对象软件的基础&gt;, &lt;代码整洁之道&gt;, &lt;重构 改善既有代码的质量&gt;, &lt;领域驱动设计&gt;之类的悄悄爬上了你的书桌.</more></effective></p><p>第三阶段, 你开始想要去了解更多的细节, 挖掘更多深层次的内容. 看源码, 自己写库, 并且N多C++程序员最爱的工作造轮子就会发生在此时.</p><p>其实还有很多想法, 但是总觉得太过碎片化, 可能以后留着更新吧</p><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;临近年关了, 最近的工作重心也落到了聊聊绩效和未来一年的规划, 能够感受到大家的对未来的憧憬, 也有很多迷茫和彷徨, 但是总体来说氛围还是比较向上的.&lt;/p&gt;
&lt;p&gt;因为最近Review了不少代码, 有相当一部分是我自己不熟悉的功能, 需要花费一些精力去了解背后的逻辑, 所
      
    
    </summary>
    
    
      <category term="C#" scheme="http://nas.lus.red/tags/C/"/>
    
      <category term="C++" scheme="http://nas.lus.red/tags/C/"/>
    
      <category term="学习路线" scheme="http://nas.lus.red/tags/%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/"/>
    
  </entry>
  
  <entry>
    <title>没有硝烟的战场--索罗斯 VS 香港</title>
    <link href="http://nas.lus.red/%E6%B2%A1%E6%9C%89%E7%A1%9D%E7%83%9F%E7%9A%84%E6%88%98%E5%9C%BA-%E7%B4%A2%E7%BD%97%E6%96%AF-VS-%E9%A6%99%E6%B8%AF.html"/>
    <id>http://nas.lus.red/没有硝烟的战场-索罗斯-VS-香港.html</id>
    <published>2020-01-11T14:29:16.000Z</published>
    <updated>2020-01-11T15:03:01.984Z</updated>
    
    <content type="html"><![CDATA[<p>最近刷B站有点多, 主要是为了学习, 然后关注了一波涨姿势的UP主.</p><p>其中<strong>巫师财经</strong>是我收藏夹里已经躺了老久了, <strong>lKs</strong>之前有一期视频, 讲述视频拍摄成本中, 就拿<strong>党妹</strong>, <strong>巫师财经</strong>等人举了例子, 其中对于<strong>巫师财经</strong>不乏溢美之词, 在他们去拍摄<strong>百万奢侈品进当铺</strong>那一集中, 富婆<strong>十音</strong>也直接一句不介绍了, 有兴趣的请去看巫师财经节目云云.</p><p>然后今天看了后, 真香!</p><a id="more"></a><p><iframe src="//player.bilibili.com/player.html?aid=76976895&cid=131705253&page=1" height="800" width="600" scrolling="true" border="0" frameborder="no" framespacing="0" allowfullscreen="true"> </iframe><br>UP主思路明确, 切入点出色, 将索罗斯做空这十余年的大事娓娓道来, 巧妙的降维到幼儿园, 保证了整个叙述的完整性.</p><p><iframe src="//player.bilibili.com/player.html?aid=71420798&cid=123730890&page=1" width="600" height="800" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true"> </iframe><br>另一篇保时捷大众的大战, 虽然已经过去了十数年, 但是详细的资料依然令人动容.</p><p><iframe src="//player.bilibili.com/player.html?aid=68401584&cid=118551810&page=1" height="800" width="600" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true"> </iframe><br>这个视频则是让人对于金融从业者有了更多的了解.</p><p>其他的做了一些明星和奢侈品之类相关的, 有点蹭热度试探粉丝的感觉, 而且据说作者从中行离开后也开始自己创业了, 希望以后不要变成了恰饭视频…</p><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近刷B站有点多, 主要是为了学习, 然后关注了一波涨姿势的UP主.&lt;/p&gt;
&lt;p&gt;其中&lt;strong&gt;巫师财经&lt;/strong&gt;是我收藏夹里已经躺了老久了, &lt;strong&gt;lKs&lt;/strong&gt;之前有一期视频, 讲述视频拍摄成本中, 就拿&lt;strong&gt;党妹&lt;/strong&gt;, &lt;strong&gt;巫师财经&lt;/strong&gt;等人举了例子, 其中对于&lt;strong&gt;巫师财经&lt;/strong&gt;不乏溢美之词, 在他们去拍摄&lt;strong&gt;百万奢侈品进当铺&lt;/strong&gt;那一集中, 富婆&lt;strong&gt;十音&lt;/strong&gt;也直接一句不介绍了, 有兴趣的请去看巫师财经节目云云.&lt;/p&gt;
&lt;p&gt;然后今天看了后, 真香!&lt;/p&gt;
    
    </summary>
    
      <category term="财经" scheme="http://nas.lus.red/categories/%E8%B4%A2%E7%BB%8F/"/>
    
    
      <category term="财经" scheme="http://nas.lus.red/tags/%E8%B4%A2%E7%BB%8F/"/>
    
      <category term="视频" scheme="http://nas.lus.red/tags/%E8%A7%86%E9%A2%91/"/>
    
  </entry>
  
  <entry>
    <title>&lt;程序员的三门课&gt;读书笔记</title>
    <link href="http://nas.lus.red/%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E4%B8%89%E9%97%A8%E8%AF%BE-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0.html"/>
    <id>http://nas.lus.red/程序员的三门课-读书笔记.html</id>
    <published>2020-01-10T15:39:04.000Z</published>
    <updated>2020-01-22T14:17:53.815Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://img.lus.red/blog/VMLRY0.png" alt="封面"></p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">主观评分: 7</span><br><span class="line">花费时间: 8h(粗读)</span><br><span class="line">一句点评: 这是一个IT人实践的记录, 作者想要讲得广, 不知是限于篇幅还是自身能力, 最后变成了水.</span><br></pre></td></tr></table></figure><a id="more"></a><p>[toc]</p><p>作为一个爱囤书的仓鼠党, 每月惯例就是看看有啥子新书可以买买买, 在新书里看到了这本&lt;程序员的三门课–技术精讲 架构设计 管理探秘&gt;, 书的内容分为三大部分:</p><ul><li><p>介绍程序员的技能成才路径</p></li><li><p>架构思维模式, 架构设计过程</p></li><li><p>做技术管理的的诀窍</p></li></ul><p>看着就是干货满满, 包罗万象的样子, 虽说按照一般经验来说, 国内作者这种样样通的书往往会很水 但是还是欣然购入喜加一.</p><p>本书主要是于泽君的自己的一些理解和感悟, 和自己成长过程中的新路历程及他的一些总结, 同时也邀请了其他4位作者一起合作的书, 可以看出来, 不管是行书的结构还是字里行间, 还是以他为主, 其他人为辅助, 他的技术栈是以<strong>Java</strong>为主, 在架构方面, 也以<strong>领域模型</strong>和<strong>分层</strong>介绍得最为详细, 而管理相关的就相对没有那么系统性的方法论, 而是更多零碎的个人经验.</p><p><strong>史海峰</strong>的推荐序我个人甚是喜欢, 他讲述的是<strong>世界上需要什么样的程序员</strong>, 他认为好的程序员应该是<strong>工型人才</strong>, 一横: 具备完成完整应用的能力, 包括运维, 成为熟手; 一纵:在某些领域足够深入, 成为高手; 一横: 达到更高水平后, 兼容多个领域, 成为驱动着和领导者. </p><h2><span id="程序员的技能与成长">程序员的技能与成长</span></h2><h3><span id="如何学习一门新语言">如何学习一门新语言</span></h3><p>在学习一门语言时, 重点应该关注三个点: <strong>基本表达形式</strong>, <strong>组合的方法</strong>, <strong>抽象的方法</strong>.<br>这三点对应的其实就是三个点: 基础知识, 应用和设计.</p><p>动态语言, 静态语言, 强类型语言, 弱类型语言, 编译型语言, 解释型语言, 都要浅尝辄止.<br>只有看多了, 你才能更加领略每种语言的其中三味, 所以我打算后面先学Python, 然后LISP, 这里先立个Flag.</p><p>我记得C语言之父在写<essential c++="">的时候就提到了关于学习的一些话题, 在完成了史诗般巨作的&lt;C++ Primer&gt;之后, 他发现这本砖头书实在是不适合入门, 所以他回头头来写了<essential c++="">, 在这本书, 他不再按照面面俱到的细数所有C++特性, 而是将C++的几种编程范式, 通过精心准备的由浅入深的例子来呈现. 虽然我了解到这本书的时候已经过了入门这个槛了, 但是看看还是收益良多的. </essential></essential></p><p>因为语言不仅仅是语法, 在刚开始学习的时候, 总觉得像&lt;精通Visual C++&gt;这种书, 简单又明了, 所有概念都分门别类, 一条条的特别清楚. 直到自己用了多年, 才感受到语言自有魅力和逻辑, 而不仅仅是搬砖那么简单.</p><p>其他的一些经验, 比如带着问题去学习, 勤加练习, 教学相长之类的, 都算是老生常谈了.</p><h3><span id="测试驱动开发">测试驱动开发</span></h3><p>作者似乎非常推崇测试驱动开发, 他提到了自己曾经做了一件现在看起来不靠谱的事情, 就是把一个模块的代码测试覆盖率达到了80%, 但是测试覆盖率低的原因往往是:</p><ul><li><p>团队成员没有写测试的习惯, 没有意识到其重要性, 不想写</p></li><li><p>代码难于测试, 不会写</p></li><li><p>赶进度, 没有时间写</p></li></ul><p>相比于提高覆盖率, 解决这些问题更加重要, 代码覆盖率的提升, 从本质上来说并不是解决这些问题的良药, 糟糕的代码哪怕你提高了测试覆盖率, 在面对新需求时, 可能又是一堆无效且累赘的代码.</p><p>这件事我感受颇为深刻, 因为同样的事情我也做过, 然后半途而废了. 为啥? 因为我发现单元测试虽然能对代码质量有所帮助, 但是更大的问题其实在于糟糕的设计, 抱歉真的是非常糟糕, 而且很多还是自己挖的坑, 可能真的是需要重构这把钥匙才有希望解决这些问题, 如今的自己还是没有真正的想好, 后面应该怎么样做.我们不仅违反了测试驱动设计的步骤, 甚至还违反了同步编写开发代码和测试代码的思路, 可能过年的时候, 自己好好实践下, TDD是不是真的是灵丹妙药了. </p><p>然后作者这里就开始水了N页, 去给出了一个TDD的操作例子, 没办法, Java的框架巴拉巴拉的代码一写上, 动辄就是一页的代码, 这个我还是觉得&lt;C++程序设计与实践: 测试驱动开发&gt;这本书写得更详尽和深入一点.</p><h3><span id="静态代码分析">静态代码分析</span></h3><p>作者分享了一些Java的静态代码分析工具, 对于一个CLike语言的使用者, 又是几大章跳过的内容, 目前自用的CppCheck和Visual Studio的代码分析工具还是挺好用的.</p><h3><span id="代码审查">代码审查</span></h3><p>这一章对我而言感觉非常重要, 因为自己最近也在做代码审查工作, 但是效果不好(虽然总有一种正在渐入佳境的错觉), 个人思来想去外加问大佬后的最终结论是: <strong>自己太菜了</strong>.为什么审核不出结果? 是因为自己太菜了, 全程都没法跟上别人的思路, 那除了简单的看看逻辑有没有错误, 谈何从设计从更高的层次去发现问题?</p><p>关于代码审查, 从一个评审人的角度, 我个人的观点是这样的:</p><ul><li><p>将代码放在整个环境去中看, 并不是一个片段, 除非你很熟悉, 不然光Diff不是一个优秀的审查方法</p></li><li><p>代码审查是一个持续性的工作, 快速的反馈, 不懂就问</p></li><li><p>代码审查不仅是个审查的机会, 更是个学习的机会</p></li></ul><p>而作者似乎对工具比较推崇, 认为工具和检查清单在整个代码审查过程中都很重要, 这点我只能说认同一半吧, 工具只是提高效率, 但是更多的功夫是在评审之外的.</p><h3><span id="工具化">工具化</span></h3><p>对于统一的工具平台, 需要考虑不同工具的层次, 使其能够尽量的复用; 对于差异较大的, 则分别建设.</p><p>我发现作者似乎对于工具和自动化特别的推崇, 可能是我对Java的理解还停留在以前使用Eclipse开发的古老年代, 在那个年代Java中有大量大量的简单而又机械的工作, C++程序员老是在造轮子….</p><h3><span id="自动化">自动化</span></h3><p>自动化测试作为有效的提效手段, 是每个技术团队都在追求的目标. 核心问题有两个: <strong>分层</strong>和<strong>稳定</strong>.</p><p>分层: 各种复杂功能需要不同的粒度来保证, 单元测试, 组件测试, 接口测试, 灰度测试等需要结合使用.</p><p>稳定: 持续集成的基础, 自动化屏蔽了逻辑的细节, 将前人的测试经验代码化了, 所以引入了一个测试成熟度: 一方面评价代码覆盖, 另一方面评价CI的通过率.</p><h3><span id="文档">文档</span></h3><p>又是一个痛点. 传统的文档管理方式, 总是让人迷失在文档的海洋里…</p><p>作者的几个观点虽然比较零碎, 但也有一定的道理:</p><ul><li>研发过程的关键文档: 需求和系统分析</li><li>Core文档, 必须定期维护</li><li>用例即文档</li><li>API接口生成</li></ul><h3><span id="程序员的工具箱">程序员的工具箱</span></h3><p>Perl之父Larry Wall提到: 程序员的三个美德是懒惰, 懒惰和懒惰. 作者在这里提到了许多能够提升程序员工作效率的软硬件, 还有在线工具.</p><h2><span id="加速成长与学习">加速成长与学习</span></h2><p>积极主动, 选择合适的平台, 别怕犯错, 注意细节, 时间管理, 打破边界, 带着思考写代码.</p><p>其实我认为最最重要的两点就是时间管理和带着思考写代码.</p><p>时间管理这个问题有点老生常谈了, 但是作者关于会议的一些经验, 还是很有帮助的:</p><ul><li>参加必要的会议, 尽量避免参加不必要的会议.</li><li>尽量不要让不紧要的讨论打断正在做的事情</li><li>可以提前约定时间, 不需要再专注于代码的时间段打扰自己</li></ul><p>然后就是重要紧急四象限, 优先做重要的事情!</p><p>带着思考去写代码也很重要, 写代码也分几个层次: </p><ul><li>第一个层次, 让代码写得不一样, 规范性, 可读性, 可扩展性…</li><li>第二个层次, 考虑业务问题和技术问题的匹配, 可以从写业务代码中理解需求, 做好分析和设计.</li><li>第三个层次, 总结相关方法体系, 成为业务及技术的双料专家.</li></ul><h3><span id="学会学习">学会学习</span></h3><p>管理好自己的目标, 利用好碎片化时间, 一次只做一件事.</p><h4><span id="两个著名的学习理论">两个著名的学习理论</span></h4><h4><span id="德雷福斯模型">德雷福斯模型</span></h4><p>一种衡量人们的工作方法和能力, 反省并提高专业技能的层级模型:</p><ul><li>新手: 需要指令清单, 很少的经验, <strong>通过模仿和观察来学习</strong></li><li>高级新手: 不需要全局思维, 可以独立尝试任务, 但扔难以解决问题</li><li>胜任者: 能够解决问题</li><li>精通者: 能够自我纠正, 需要全局思维, 将围绕某种技术, 寻找并想了解更大的概念框架</li><li>专家: 专家凭借直觉工作, 有丰富的经验, 可以在前挡的情境中选取和应用自己的经验, <strong>需要保持实践来维持水平</strong></li></ul><h4><span id="刻意锻炼理论">刻意锻炼理论</span></h4><p>专家水平是可以训练出来的.</p><h2><span id="业务分析与设计">业务分析与设计</span></h2><p>用特定的方式或方法, 把复杂的需求拆解成更简单并且容易理解的对象, 并找出这些对象间的关系</p><h3><span id="领域驱动设计ddd">领域驱动设计(DDD)</span></h3><p>领域驱动设计提出了领域模型的概念, 抛弃了将分析与设计分开的做法, 使用统一的模型来满足分析与设计的需求. 领域设计 = 边界 + 设计; 有界上下文 = 用户 + 领域 + 功能. 那么领域驱动设计就是一种定义边界, 并且在设计阶段融合了原形的设计方法?</p><p>领域驱动设计的三个核心原则:</p><ul><li>把项目的重点放在核心域和域逻辑上</li><li>把复杂的设计放在有界域模型上</li><li>和领域专家不断协作晚上应用模型来解决特定领域的问题</li></ul><p>领域驱动设计就是先将领域中涉及的数据,流程,商业规规则等都弄明白, 然后以面向对象的观点为其建立一个领域模型, 再选用合适的软件技术实现这个模型. 问题域就是数据, 流程和规则; 问题解决域就是用软件去实现这个模型.</p><p><strong>后续需要补充一些相关资料来学习, 作者这里写得太乱了, 看着吃力</strong></p><h2><span id="架构修炼">架构修炼</span></h2><h3><span id="分解">分解</span></h3><p>高内聚, 低耦合; 层次性; 正交原则(分层后都是独立的); 抽象; 稳定; 复用</p><h3><span id="复用">复用</span></h3><p>可扩展性, 灵活性, 可插入性.一个复杂性较好的系统, 就是一个易维护的系统.</p><p>为了可维护性, 我们有一些原则:</p><ul><li><p>开闭原则</p><p>抽象化是开闭原则的关键, 可以为系统定义一个稳定的抽象层, 将不同的实现行为移至具体的实现层.</p></li><li><p>LSP里氏代换原则</p><p>将基类替换成子类对象不会有任何错误, 这个就是实现开闭原则的重要方式之一.</p></li><li><p>DIP依赖倒置</p><p>依赖于抽象而不是实现</p></li><li><p>ISP接口隔离原则</p><p>每个接口应该承担一种相对独立的角色,不干不该干的事情.</p></li><li><p>CARP组合聚合复用原则</p><p>尽量使用组合或聚合关系,少用继承. 使用继承复用会破坏系统的封装性.</p></li><li><p>LoD迪米特法则</p><p>尽量减少对象直接的通信</p></li></ul><h3><span id="模式">模式</span></h3><p>根据业务需求来选择最合适的技术, 而不是用主流和最先进的技术去反推业务.</p><p>作者介绍了一些模式, 但都比较简单, 我觉得后面可以专门写一篇模式相关的文章来说这个问题, 这里仅做简单的说明, 而且我觉得这里虽然都是模式,但是领域不一样, 放在一起写挺奇怪的…</p><ul><li><p>分层</p><p>每层只能与位于其下方的层发生耦合, 四层/五层/六边形架构都是领域驱动比较经典的架构.</p></li><li><p>C/S</p><p>客户端/服务器模式</p></li><li><p>主从</p></li><li><p>管道-过滤器</p><p>一种松耦合的设计模式, 各过滤器只需要实现单一功能, 降低了依赖和复杂度</p></li><li><p>代理</p><p>在结构和系统中对组件进行解耦, 组件之间都过RPC的方式进行交互, 代码组件则用于协调.</p></li><li><p>P2P</p></li><li><p>事件总线</p><p>事件源, 事件监视器, 通道和事件总线.</p></li><li><p>MVC</p></li><li><p>黑板</p><p>观察者模式的扩展, 包括知识源, 黑板数据和控制; 相比观察者, 多了黑板数据模式匹配.</p></li><li><p>解释器</p></li></ul><h3><span id="结构化">结构化</span></h3><p>Who, What, When, Where, Why, How, How much</p><h3><span id="架构设计">架构设计</span></h3><p>稳定, 解耦, 抽象, 松耦合, 容错</p><h3><span id="技术架构">技术架构</span></h3><p>无状态, 可复用, 松耦合, 可治理, 基础服务(这个是适用于网络的)</p><h3><span id="架构设计的流程">架构设计的流程</span></h3><p>这里作者提到了学习<strong>元模型</strong>, 来自己设计, 后续给出的都是Web开发的一些例子, 就暂时不看了.</p><h2><span id="质量与风险">质量与风险</span></h2><h3><span id="pdca">PDCA</span></h3><p>Plan, Do. Check, Act</p><h3><span id="可能引起质量问题的坑">可能引起质量问题的坑</span></h3><p>业务发展, 问题域的复杂性, 系统的复杂性, 技术债, 人/流程/文档的博弈, 采用不能掌控的工具和框架, 质量意识</p><h2><span id="管理">管理</span></h2><p>必须的技能准备, 视角转换, 学会用户思维, 建立经济视角, 成为内部商务合作, 规划团队从规划自己开始, 数据驱动</p><p>技术领导力4个维度:</p><ul><li>提供清晰的领导力风格, 并以信任感作为基石</li><li>了解业务, 并带领团队到到高绩效</li><li>发展自己和团队成员</li><li>塑造未来</li></ul><p>让自己成为T型人才:</p><ul><li>离开舒适区</li><li>坚持阅读和与不同领域的人交流</li><li>创造需求, 基石应用和实践自己掌握的知识</li><li>尝试训练自己动多角度看待问题</li><li>给学习和应用设定目标和里程碑</li></ul><p>高效管理时间:</p><ul><li>确定在做的事情符合自己的目标</li><li>随时应用80/20法则</li><li>创造大块的时间</li></ul><p>如何解决不服的员工</p><p>如何处理冲突</p><p>如何管理更多人员</p><p>从管理这章而言, 我最大的体会还是自己把时间和精力都花在了不重要的事情上, 导致整个团队的效率是在下降的, 后续会思考如何让我们整个团队保持一个更高的效率!</p><h2><span id="总结">总结</span></h2><p>总得看下来, 这本书的质量其实并不高, 里面很多的内容其实是作者的经验谈, 结合了一些比较泛泛的方法论, 组织上追求全而缺乏核心主题, 所以不是很系统, 看上去就特别空, 有一种背概念的感觉. </p><p>其中的一些经验比如说团队管理和个人管理, 对我个人而言, 还是很有借鉴和帮助的, 但是技术路线就差的比较远了.</p><h2><span id="todo">TODO</span></h2><p>了解DDD领域驱动设计</p><p>使用TDD开发一个小项目</p><p>整理书中提到的模式和应用场景</p><p>在团队中尝试使用OKR的方式来管理目标</p><p>使用德雷福斯模型分析团队现状, 并制定发展规划</p><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://img.lus.red/blog/VMLRY0.png&quot; alt=&quot;封面&quot;&gt;&lt;/p&gt;
&lt;figure class=&quot;highlight plain hljs&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;主观评分: 7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;花费时间: 8h(粗读)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;一句点评: 这是一个IT人实践的记录, 作者想要讲得广, 不知是限于篇幅还是自身能力, 最后变成了水.&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="读书笔记" scheme="http://nas.lus.red/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="读书笔记" scheme="http://nas.lus.red/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
      <category term="方法论" scheme="http://nas.lus.red/tags/%E6%96%B9%E6%B3%95%E8%AE%BA/"/>
    
      <category term="程序员" scheme="http://nas.lus.red/tags/%E7%A8%8B%E5%BA%8F%E5%91%98/"/>
    
  </entry>
  
  <entry>
    <title>lua序列化</title>
    <link href="http://nas.lus.red/lua%E5%BA%8F%E5%88%97%E5%8C%96.html"/>
    <id>http://nas.lus.red/lua序列化.html</id>
    <published>2018-12-07T14:16:57.000Z</published>
    <updated>2018-12-07T14:58:44.420Z</updated>
    
    <content type="html"><![CDATA[<p>将一个表序列化成一个字符串, 逻辑很简单, 就是递归调用 + 类型判断.</p><figure class="highlight lua hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment">-- 字符串序列化 + 缩进</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">serialize</span><span class="hljs-params">(param, level)</span></span></span><br><span class="line">    <span class="hljs-keyword">local</span> result = <span class="hljs-string">""</span></span><br><span class="line">    <span class="hljs-keyword">local</span> space = <span class="hljs-string">""</span></span><br><span class="line">    <span class="hljs-keyword">local</span> t = <span class="hljs-built_in">type</span>(param)</span><br><span class="line">    <span class="hljs-keyword">if</span> (<span class="hljs-literal">nil</span> == level) <span class="hljs-keyword">then</span></span><br><span class="line">        level = <span class="hljs-number">0</span></span><br><span class="line">    <span class="hljs-keyword">end</span></span><br><span class="line">    <span class="hljs-keyword">for</span> i = <span class="hljs-number">1</span>, level <span class="hljs-keyword">do</span></span><br><span class="line">        space = space .. <span class="hljs-string">"\t"</span></span><br><span class="line">    <span class="hljs-keyword">end</span></span><br><span class="line">    </span><br><span class="line">    <span class="hljs-keyword">if</span> t == <span class="hljs-string">"number"</span> <span class="hljs-keyword">then</span></span><br><span class="line">        result = result .. param</span><br><span class="line">    <span class="hljs-keyword">elseif</span> t == <span class="hljs-string">"boolean"</span> <span class="hljs-keyword">then</span></span><br><span class="line">        result = result .. <span class="hljs-built_in">tostring</span>(param)</span><br><span class="line">    <span class="hljs-keyword">elseif</span> t == <span class="hljs-string">"string"</span> <span class="hljs-keyword">then</span></span><br><span class="line">        result = result .. <span class="hljs-built_in">string</span>.<span class="hljs-built_in">format</span>(<span class="hljs-string">"%q"</span>, param)</span><br><span class="line">    <span class="hljs-keyword">elseif</span> t == <span class="hljs-string">"table"</span> <span class="hljs-keyword">then</span></span><br><span class="line">        result = result .. <span class="hljs-string">"&#123;\n"</span></span><br><span class="line">        <span class="hljs-keyword">for</span> k, v <span class="hljs-keyword">in</span> <span class="hljs-built_in">pairs</span>(param) <span class="hljs-keyword">do</span></span><br><span class="line">            result = result .. space .. <span class="hljs-string">"\t"</span> .. <span class="hljs-string">"["</span> .. serialize(k) .. <span class="hljs-string">"] = "</span></span><br><span class="line">            .. serialize(v, level + <span class="hljs-number">1</span>) .. <span class="hljs-string">",\n"</span></span><br><span class="line">        <span class="hljs-keyword">end</span></span><br><span class="line">        </span><br><span class="line">        <span class="hljs-keyword">local</span> metatable = <span class="hljs-built_in">getmetatable</span>(param)</span><br><span class="line">        <span class="hljs-keyword">if</span> metatable ~= <span class="hljs-literal">nil</span> <span class="hljs-keyword">and</span> <span class="hljs-built_in">type</span>(metatable.<span class="hljs-built_in">__index</span>) == <span class="hljs-string">"table"</span> <span class="hljs-keyword">then</span></span><br><span class="line">            <span class="hljs-keyword">for</span> k, v <span class="hljs-keyword">in</span> <span class="hljs-built_in">pairs</span>(metatable.<span class="hljs-built_in">__index</span>) <span class="hljs-keyword">do</span></span><br><span class="line">                result = result .. <span class="hljs-string">"["</span> .. serialize(k) .. <span class="hljs-string">"] = "</span></span><br><span class="line">                .. serialize(metatable.<span class="hljs-built_in">__index</span>[v], level + <span class="hljs-number">1</span>) .. <span class="hljs-string">",\n"</span></span><br><span class="line">            <span class="hljs-keyword">end</span></span><br><span class="line">        <span class="hljs-keyword">end</span></span><br><span class="line">        result = result .. space .. <span class="hljs-string">"&#125;"</span></span><br><span class="line">    <span class="hljs-keyword">elseif</span> t == <span class="hljs-string">"nil"</span> <span class="hljs-keyword">then</span></span><br><span class="line">        <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span></span><br><span class="line">    <span class="hljs-keyword">else</span></span><br><span class="line">        <span class="hljs-comment">-- @warning 不支持表中的function的序列化</span></span><br><span class="line">    <span class="hljs-keyword">end</span></span><br><span class="line">    <span class="hljs-keyword">return</span> result</span><br><span class="line"><span class="hljs-keyword">end</span></span><br></pre></td></tr></table></figure><a id="more"></a><p>测试<br><figure class="highlight lua hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">tb = </span><br><span class="line">&#123;</span><br><span class="line">    a = <span class="hljs-string">'a'</span>,</span><br><span class="line">    b = <span class="hljs-string">"banana"</span>,</span><br><span class="line">    c = &#123;</span><br><span class="line">        <span class="hljs-number">1</span>,</span><br><span class="line">        <span class="hljs-number">2</span>,</span><br><span class="line">        <span class="hljs-number">3</span>,</span><br><span class="line">        hello = <span class="hljs-string">"world"</span></span><br><span class="line">    &#125;,</span><br><span class="line">    d = <span class="hljs-number">10</span>,</span><br><span class="line">    <span class="hljs-string">"e"</span>,</span><br><span class="line">    <span class="hljs-string">"f"</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-built_in">print</span>(serialize(tb))</span><br></pre></td></tr></table></figure></p><p>输出结果<br><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">[1] = &quot;e&quot;,</span><br><span class="line">[2] = &quot;f&quot;,</span><br><span class="line">[&quot;b&quot;] = &quot;banana&quot;,</span><br><span class="line">[&quot;c&quot;] = &#123;</span><br><span class="line">[1] = 1,</span><br><span class="line">[2] = 2,</span><br><span class="line">[3] = 3,</span><br><span class="line">[&quot;hello&quot;] = &quot;world&quot;,</span><br><span class="line">&#125;,</span><br><span class="line">[&quot;a&quot;] = &quot;a&quot;,</span><br><span class="line">[&quot;d&quot;] = 10,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
    
    <summary type="html">
    
      &lt;p&gt;将一个表序列化成一个字符串, 逻辑很简单, 就是递归调用 + 类型判断.&lt;/p&gt;
&lt;figure class=&quot;highlight lua hljs&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;26&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;27&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;28&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;29&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;30&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;31&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;32&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;33&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;34&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;35&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;36&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;37&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;38&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;39&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;40&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;hljs-comment&quot;&gt;-- 字符串序列化 + 缩进&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;serialize&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(param, level)&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;hljs-keyword&quot;&gt;local&lt;/span&gt; result = &lt;span class=&quot;hljs-string&quot;&gt;&quot;&quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;hljs-keyword&quot;&gt;local&lt;/span&gt; space = &lt;span class=&quot;hljs-string&quot;&gt;&quot;&quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;hljs-keyword&quot;&gt;local&lt;/span&gt; t = &lt;span class=&quot;hljs-built_in&quot;&gt;type&lt;/span&gt;(param)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt; (&lt;span class=&quot;hljs-literal&quot;&gt;nil&lt;/span&gt; == level) &lt;span class=&quot;hljs-keyword&quot;&gt;then&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        level = &lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;hljs-keyword&quot;&gt;end&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;hljs-keyword&quot;&gt;for&lt;/span&gt; i = &lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;, level &lt;span class=&quot;hljs-keyword&quot;&gt;do&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        space = space .. &lt;span class=&quot;hljs-string&quot;&gt;&quot;\t&quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;hljs-keyword&quot;&gt;end&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt; t == &lt;span class=&quot;hljs-string&quot;&gt;&quot;number&quot;&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;then&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        result = result .. param&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;hljs-keyword&quot;&gt;elseif&lt;/span&gt; t == &lt;span class=&quot;hljs-string&quot;&gt;&quot;boolean&quot;&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;then&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        result = result .. &lt;span class=&quot;hljs-built_in&quot;&gt;tostring&lt;/span&gt;(param)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;hljs-keyword&quot;&gt;elseif&lt;/span&gt; t == &lt;span class=&quot;hljs-string&quot;&gt;&quot;string&quot;&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;then&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        result = result .. &lt;span class=&quot;hljs-built_in&quot;&gt;string&lt;/span&gt;.&lt;span class=&quot;hljs-built_in&quot;&gt;format&lt;/span&gt;(&lt;span class=&quot;hljs-string&quot;&gt;&quot;%q&quot;&lt;/span&gt;, param)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;hljs-keyword&quot;&gt;elseif&lt;/span&gt; t == &lt;span class=&quot;hljs-string&quot;&gt;&quot;table&quot;&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;then&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        result = result .. &lt;span class=&quot;hljs-string&quot;&gt;&quot;&amp;#123;\n&quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;hljs-keyword&quot;&gt;for&lt;/span&gt; k, v &lt;span class=&quot;hljs-keyword&quot;&gt;in&lt;/span&gt; &lt;span class=&quot;hljs-built_in&quot;&gt;pairs&lt;/span&gt;(param) &lt;span class=&quot;hljs-keyword&quot;&gt;do&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            result = result .. space .. &lt;span class=&quot;hljs-string&quot;&gt;&quot;\t&quot;&lt;/span&gt; .. &lt;span class=&quot;hljs-string&quot;&gt;&quot;[&quot;&lt;/span&gt; .. serialize(k) .. &lt;span class=&quot;hljs-string&quot;&gt;&quot;] = &quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            .. serialize(v, level + &lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;) .. &lt;span class=&quot;hljs-string&quot;&gt;&quot;,\n&quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;hljs-keyword&quot;&gt;end&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;hljs-keyword&quot;&gt;local&lt;/span&gt; metatable = &lt;span class=&quot;hljs-built_in&quot;&gt;getmetatable&lt;/span&gt;(param)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt; metatable ~= &lt;span class=&quot;hljs-literal&quot;&gt;nil&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;and&lt;/span&gt; &lt;span class=&quot;hljs-built_in&quot;&gt;type&lt;/span&gt;(metatable.&lt;span class=&quot;hljs-built_in&quot;&gt;__index&lt;/span&gt;) == &lt;span class=&quot;hljs-string&quot;&gt;&quot;table&quot;&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;then&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;hljs-keyword&quot;&gt;for&lt;/span&gt; k, v &lt;span class=&quot;hljs-keyword&quot;&gt;in&lt;/span&gt; &lt;span class=&quot;hljs-built_in&quot;&gt;pairs&lt;/span&gt;(metatable.&lt;span class=&quot;hljs-built_in&quot;&gt;__index&lt;/span&gt;) &lt;span class=&quot;hljs-keyword&quot;&gt;do&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                result = result .. &lt;span class=&quot;hljs-string&quot;&gt;&quot;[&quot;&lt;/span&gt; .. serialize(k) .. &lt;span class=&quot;hljs-string&quot;&gt;&quot;] = &quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                .. serialize(metatable.&lt;span class=&quot;hljs-built_in&quot;&gt;__index&lt;/span&gt;[v], level + &lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;) .. &lt;span class=&quot;hljs-string&quot;&gt;&quot;,\n&quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;hljs-keyword&quot;&gt;end&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;hljs-keyword&quot;&gt;end&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        result = result .. space .. &lt;span class=&quot;hljs-string&quot;&gt;&quot;&amp;#125;&quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;hljs-keyword&quot;&gt;elseif&lt;/span&gt; t == &lt;span class=&quot;hljs-string&quot;&gt;&quot;nil&quot;&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;then&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;hljs-literal&quot;&gt;nil&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;hljs-keyword&quot;&gt;else&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;hljs-comment&quot;&gt;-- @warning 不支持表中的function的序列化&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;hljs-keyword&quot;&gt;end&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; result&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;end&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="lua" scheme="http://nas.lus.red/categories/lua/"/>
    
    
      <category term="lua" scheme="http://nas.lus.red/tags/lua/"/>
    
      <category term="序列化" scheme="http://nas.lus.red/tags/%E5%BA%8F%E5%88%97%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>&lt;C++性能优化&gt;读后感</title>
    <link href="http://nas.lus.red/C-%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96-%E8%AF%BB%E5%90%8E%E6%84%9F.html"/>
    <id>http://nas.lus.red/C-性能优化-读后感.html</id>
    <published>2018-12-02T17:28:02.000Z</published>
    <updated>2020-01-10T20:02:34.014Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://img.lus.red/blog/OrmPGU.png" alt="封面" style="zoom:50%;"></p><p>拜读了<code>Kurt Guntherot</code>h的<code>Optimized C++: Proven Techniques for Heightened Performance(&lt;C++性能优化指南&gt;)</code>, 除了要吐槽下作者各种强行引用各种名人名言外, 还是受益良多的. 之前对于性能优化, 比较茫然, 最多也就能说得出一些常用的优化手段, 比如不用值传递啊, vector需要reverse啊, 各种排序算法性能啊.. 总之就是杂七杂八根据没个头绪.</p><p>最大的感受就是一点: 法有尽, 而术无穷.</p><p>现在的计算机性能不断增长, 所以即使是性能优化, 也在不断的演进. 一些比如PIMPL之类, 针对于以前编译慢的优化, 在如今, 完全可以忽略不计了.对于现在的C++性能优化, 我们应该抓住其主要矛盾: 1. 算法/逻辑 2. 硬件瓶颈.</p><p>从算法逻辑的角度, 选用更好的编译器, 更好的处理逻辑, 更好的内存结构.</p><p>从硬件的角度, 处理现在最大的瓶颈—内存, 减少内存分配复制.</p><p>现在只是简单过了一遍, 对于其中的并发优化, 内存管理器优化等还是需要进一步学习. 打算后面再看下Windows/Visual Studio相关的性能分析和优化等, 重新好好做个总结.</p><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;img src=&quot;http://img.lus.red/blog/OrmPGU.png&quot; alt=&quot;封面&quot; style=&quot;zoom:50%;&quot;&gt;&lt;/p&gt;
&lt;p&gt;拜读了&lt;code&gt;Kurt Guntherot&lt;/code&gt;h的&lt;code&gt;Optimized C++: Pro
      
    
    </summary>
    
      <category term="读书笔记" scheme="http://nas.lus.red/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="C++" scheme="http://nas.lus.red/tags/C/"/>
    
      <category term="性能优化" scheme="http://nas.lus.red/tags/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"/>
    
      <category term="阅读" scheme="http://nas.lus.red/tags/%E9%98%85%E8%AF%BB/"/>
    
  </entry>
  
  <entry>
    <title>lua的capi</title>
    <link href="http://nas.lus.red/lua%E7%9A%84capi.html"/>
    <id>http://nas.lus.red/lua的capi.html</id>
    <published>2018-11-26T01:09:13.000Z</published>
    <updated>2018-11-26T12:00:40.629Z</updated>
    
    <content type="html"><![CDATA[<h2><span id="概述">概述</span></h2><p>由于工作中需要使用lua + C++, 所以需要学习两者之间是如何交互的(CAPI),<br>看了一些网上的资料, 对于这方面的资料不是很详尽, 而且文章水平良莠不齐,<br>导致阅读后常陷入知其然不知其所以然的茫然.</p><p>所以自己整理了下相关的内容, 按照自己的理解, 从头到尾梳理了一下.</p><a id="more"></a><h2><span id="capi概述">CAPI概述</span></h2><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h2&gt;&lt;p&gt;由于工作中需要使用lua + C++, 所以需要学习两者之间是如何交互的(CAPI),&lt;br&gt;看了一些网上的资料, 对于这方面的资料不是很详尽, 而且文章水平良莠不齐,&lt;br&gt;导致阅读后常陷入知其然不知其所以然的茫然.&lt;/p&gt;
&lt;p&gt;所以自己整理了下相关的内容, 按照自己的理解, 从头到尾梳理了一下.&lt;/p&gt;
    
    </summary>
    
      <category term="lua" scheme="http://nas.lus.red/categories/lua/"/>
    
    
      <category term="lua" scheme="http://nas.lus.red/tags/lua/"/>
    
      <category term="capi" scheme="http://nas.lus.red/tags/capi/"/>
    
  </entry>
  
  <entry>
    <title>lua解析xml</title>
    <link href="http://nas.lus.red/lua%E8%A7%A3%E6%9E%90xml.html"/>
    <id>http://nas.lus.red/lua解析xml.html</id>
    <published>2018-11-26T01:02:57.000Z</published>
    <updated>2018-11-26T12:00:46.352Z</updated>
    
    <content type="html"><![CDATA[<h2><span id="概述">概述</span></h2><p>由于在工作中需要使用lua解析器xml, 所以学习了下相关的内容.<br>为了尽可能降低依赖, 所以使用纯lua写的xml解析, 避免引入其他依赖库, 徒添烦恼.<br>然后就找到了这个开源库:</p><p>由于这个库是基于lua5.1的, 所以他提供的require相关语法,<br>放在新版本上市不可用的, 所以稍微修改了一点, 以保证在5.1的后续版本还是可以使用.<br>以下为修改后的:</p><a id="more"></a><h2><span id="使用方法">使用方法</span></h2><h2><span id="更多思考">更多思考</span></h2><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h2&gt;&lt;p&gt;由于在工作中需要使用lua解析器xml, 所以学习了下相关的内容.&lt;br&gt;为了尽可能降低依赖, 所以使用纯lua写的xml解析, 避免引入其他依赖库, 徒添烦恼.&lt;br&gt;然后就找到了这个开源库:&lt;/p&gt;
&lt;p&gt;由于这个库是基于lua5.1的, 所以他提供的require相关语法,&lt;br&gt;放在新版本上市不可用的, 所以稍微修改了一点, 以保证在5.1的后续版本还是可以使用.&lt;br&gt;以下为修改后的:&lt;/p&gt;
    
    </summary>
    
      <category term="lua" scheme="http://nas.lus.red/categories/lua/"/>
    
    
      <category term="lua" scheme="http://nas.lus.red/tags/lua/"/>
    
      <category term="xml" scheme="http://nas.lus.red/tags/xml/"/>
    
  </entry>
  
  <entry>
    <title>hexo建站实录</title>
    <link href="http://nas.lus.red/hexo%E5%BB%BA%E7%AB%99%E5%AE%9E%E5%BD%95.html"/>
    <id>http://nas.lus.red/hexo建站实录.html</id>
    <published>2018-11-19T00:45:30.000Z</published>
    <updated>2018-11-26T00:58:43.413Z</updated>
    
    <content type="html"><![CDATA[<p>之前的小站用的wordpress, 主要也是为了写写东西记录下,<br>但是使用wordpress之后,就开始沉迷于各种插件, 比如七牛云图床插件啊,<br>Wordpress支持插件啊, 代码高亮插件啊…</p><p>还有从我的印象笔记摘抄笔记也特别麻烦, 因为显示的效果总不是很满意,<br>有鉴于此, 所以决定回归markdown,只关心写作内容.<br>目前主流的markdown建站, 也就hexo和jekyll.<br>因为之前用hexo搭过一个githubio,  所以还是选hexo了.<br>絮絮叨叨了这么多, 以下为建站实录:<br><a id="more"></a></p><h2><span id="安装hexo">安装hexo</span></h2><h3><span id="为文章指定标签">为文章指定标签</span></h3><h3><span id="为文章指定目录">为文章指定目录</span></h3><h3><span id="设定文章置顶">设定文章置顶</span></h3><h3><span id="文章显示阅读更多">文章显示”阅读更多”</span></h3><h3><span id="文章中的空格换行">文章中的空格/换行</span></h3><h2><span id="安装icuras主题">安装icuras主题</span></h2><h3><span id="安装icuras">安装icuras</span></h3><h3><span id="修改icuras的个人信息">修改icuras的个人信息</span></h3><h3><span id="修改icuras主题为双栏">修改icuras主题为双栏</span></h3><h3><span id="修改icuras目录的名字">修改icuras目录的名字</span></h3><h3><span id="修改icuras的显示宽度">修改icuras的显示宽度</span></h3><h3><span id="启用搜索插件">启用搜索插件</span></h3><h2><span id="在github上建立站点">在github上建立站点</span></h2><h2><span id="在vps上建立站点">在VPS上建立站点</span></h2><h2><span id="seo">SEO</span></h2><h3><span id="通用seo优化">通用SEO优化</span></h3><h3><span id="google">google</span></h3><h3><span id="baidu">baidu</span></h3><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
    
    <summary type="html">
    
      &lt;p&gt;之前的小站用的wordpress, 主要也是为了写写东西记录下,&lt;br&gt;但是使用wordpress之后,就开始沉迷于各种插件, 比如七牛云图床插件啊,&lt;br&gt;Wordpress支持插件啊, 代码高亮插件啊…&lt;/p&gt;
&lt;p&gt;还有从我的印象笔记摘抄笔记也特别麻烦, 因为显示的效果总不是很满意,&lt;br&gt;有鉴于此, 所以决定回归markdown,只关心写作内容.&lt;br&gt;目前主流的markdown建站, 也就hexo和jekyll.&lt;br&gt;因为之前用hexo搭过一个githubio,  所以还是选hexo了.&lt;br&gt;絮絮叨叨了这么多, 以下为建站实录:&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="网站" scheme="http://nas.lus.red/categories/%E7%BD%91%E7%AB%99/"/>
    
    
      <category term="hexo" scheme="http://nas.lus.red/tags/hexo/"/>
    
      <category term="建站" scheme="http://nas.lus.red/tags/%E5%BB%BA%E7%AB%99/"/>
    
      <category term="icuras" scheme="http://nas.lus.red/tags/icuras/"/>
    
  </entry>
  
  <entry>
    <title>C#学习笔记-委托</title>
    <link href="http://nas.lus.red/C-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E5%A7%94%E6%89%98.html"/>
    <id>http://nas.lus.red/C-学习笔记-委托.html</id>
    <published>2018-11-19T00:27:32.000Z</published>
    <updated>2020-01-11T15:05:52.019Z</updated>
    
    <content type="html"><![CDATA[<h2><span id="什么是委托">什么是委托</span></h2><p>委托是C#中的一个重要的概念.<br>委托是一个对象, 它本身含有一个或者多个方法, 可以认为是一个类型安全的, 面向对象的C++函数指针.<br>是对于C++中函数指针的一种”升级”, 因为指针除了地址本身外, 并没有办法携带其他描述的信息.<br>而委托可以</p><a id="more"></a><h2><span id="一个简单的c函数指针例子">一个简单的C++函数指针例子</span></h2><figure class="highlight c++ hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">int</span>(*Calc)(<span class="hljs-keyword">int</span> x, <span class="hljs-keyword">int</span> y);</span><br><span class="line"></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">Add</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x, <span class="hljs-keyword">int</span> y)</span></span></span><br><span class="line"><span class="hljs-function"></span>&#123;</span><br><span class="line">    <span class="hljs-keyword">return</span> x + y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">Sub</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x, <span class="hljs-keyword">int</span> y)</span></span></span><br><span class="line"><span class="hljs-function"></span>&#123;</span><br><span class="line"><span class="hljs-keyword">return</span> x - y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span></span><br><span class="line"><span class="hljs-function"></span>&#123;</span><br><span class="line">Calc = Add;</span><br><span class="line"><span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; Calc(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>) &lt;&lt; <span class="hljs-built_in">std</span>::<span class="hljs-built_in">endl</span>;</span><br><span class="line">Calc = Sub;</span><br><span class="line"><span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; Calc(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>) &lt;&lt; <span class="hljs-built_in">std</span>::<span class="hljs-built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果<br><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">3</span><br><span class="line">-1</span><br></pre></td></tr></table></figure></p><p>这里就是把函数的指针作为一个参数传递, 这样就可以通过一种方法去处理多个具有相同返回值和参数类型.</p><h2><span id="c的函数指针例子">C#的函数指针例子</span></h2><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">namespace SampleDelegate</span><br><span class="line">&#123;</span><br><span class="line">    delegate int Calc(int x, int y);</span><br><span class="line"></span><br><span class="line">    class MainClass</span><br><span class="line">    &#123; </span><br><span class="line">        static int Add(int x, int y)</span><br><span class="line">        &#123;</span><br><span class="line">            return x + y;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        static int Sub(int x, int y)</span><br><span class="line">        &#123;</span><br><span class="line">            return x - y;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        public static void Main(string[] args)</span><br><span class="line">        &#123;</span><br><span class="line">            Calc calc;</span><br><span class="line">            calc = Add;</span><br><span class="line">            Console.WriteLine(calc(1, 2));</span><br><span class="line"></span><br><span class="line">            calc = Sub;</span><br><span class="line">            Console.WriteLine(calc(1, 2));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果<br><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">3</span><br><span class="line">-1</span><br></pre></td></tr></table></figure></p><p>这个结果是C++函数指针的效果是相同的.</p><h2><span id="委托的声明和创建">委托的声明和创建</span></h2><p>委托也是一种类, 所以也是一个引用.</p><p>[delegate] [返回值] [对象名] [签名]<br>delegate void Calc(int x);</p><ol><li><p>使用new来创建<br>calc = new calc(Add);</p></li><li><p>快捷语法创建<br>calc = Add; </p></li></ol><h3><span id="委托的组合">委托的组合</span></h3><p>委托实际是一个引用, 所以委托的组合其实是指向了一个新的委托.<br><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">calc1 = Add;</span><br><span class="line">calc2 = Sub;</span><br><span class="line">calc1 = calc1 + calc2;</span><br></pre></td></tr></table></figure></p><p>也可以使用+=和-=<br><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">calc += Add;</span><br><span class="line">calc += Sub;</span><br><span class="line">calc -= Add;</span><br></pre></td></tr></table></figure></p><h2><span id="委托的使用">委托的使用</span></h2><h3><span id="带参数返回值的委托">带参数/返回值的委托</span></h3><p>如果委托有返回值, 并且方法列表不止一个方法, 那么返回值就用最后一个.</p><p>如果委托有引用参数, 在调用过程中, 会将参数的新值传给下一个方法.</p><h3><span id="泛型委托">泛型委托</span></h3><p>除了使用固定的参数, 委托也支持使用泛型<br><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">namespace SampleDelegate</span><br><span class="line">&#123;</span><br><span class="line">    delegate T Calc&lt;T&gt;(T x, T y);</span><br><span class="line"></span><br><span class="line">    class MainClass</span><br><span class="line">    &#123; </span><br><span class="line">        static int Add(int x, int y)</span><br><span class="line">        &#123;</span><br><span class="line">            return x + y;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        static double Sub(double x, double y)</span><br><span class="line">        &#123;</span><br><span class="line">            return x - y;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        public static void Main(string[] args)</span><br><span class="line">        &#123;</span><br><span class="line">            Calc&lt;int&gt; calc;</span><br><span class="line">            calc = Add;</span><br><span class="line">            Console.WriteLine(calc(1, 2));</span><br><span class="line"></span><br><span class="line">            Calc&lt;double&gt; calc2;</span><br><span class="line">            calc2 = Sub;</span><br><span class="line">            Console.WriteLine(cal2(1, 2));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4><span id="actionltgt委托">Action&lt;&gt;委托</span></h4><p>Action就是系统定义的, 返回值为void的委托.</p><h4><span id="funcltgt委托">Func&lt;&gt;委托</span></h4><p>Func就是系统定义的, 带有返回值的委托, 其中最后一个是返回值.</p><p>实际上, .Net的许多重要API都大量的使用Action和Func</p><h2><span id="委托的常见使用场景">委托的常见使用场景</span></h2><h3><span id="回调">回调</span></h3><h3><span id="使用注意事项">使用注意事项</span></h3><h2><span id="委托的代码实现">委托的代码实现</span></h2><h2><span id="本文参考">本文参考</span></h2><p>&lt;C#入门视频&gt;<br>&lt;图解C#教程&gt;<br>&lt;精通C#(第6版)&gt;</p><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;什么是委托&quot;&gt;&lt;a href=&quot;#什么是委托&quot; class=&quot;headerlink&quot; title=&quot;什么是委托&quot;&gt;&lt;/a&gt;什么是委托&lt;/h2&gt;&lt;p&gt;委托是C#中的一个重要的概念.&lt;br&gt;委托是一个对象, 它本身含有一个或者多个方法, 可以认为是一个类型安全的, 面向对象的C++函数指针.&lt;br&gt;是对于C++中函数指针的一种”升级”, 因为指针除了地址本身外, 并没有办法携带其他描述的信息.&lt;br&gt;而委托可以&lt;/p&gt;
    
    </summary>
    
      <category term="C#" scheme="http://nas.lus.red/categories/C/"/>
    
    
      <category term="C#" scheme="http://nas.lus.red/tags/C/"/>
    
      <category term="委托" scheme="http://nas.lus.red/tags/%E5%A7%94%E6%89%98/"/>
    
  </entry>
  
  <entry>
    <title>C#学习笔记</title>
    <link href="http://nas.lus.red/CSharp%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.html"/>
    <id>http://nas.lus.red/CSharp学习笔记.html</id>
    <published>2018-11-18T14:08:14.000Z</published>
    <updated>2020-01-11T15:04:10.560Z</updated>
    
    <content type="html"><![CDATA[<h2><span id="背景描述">背景描述</span></h2><p>记录自己学习C#的学习记录</p><h2><span id="阅读和学习">阅读和学习</span></h2><h3><span id="视频">视频</span></h3><ul><li>刘铁锰 <a href="https://www.bilibili.com/video/av1422127?from=search&amp;seid=17309818711796899189" target="_blank" rel="noopener">&lt;C#语言入门详解&gt;</a></li></ul><h3><span id="读书笔记">读书笔记</span></h3><h2><span id="学习笔记">学习笔记</span></h2><ul><li><a href="C-学习笔记-委托.html">委托</a></li></ul><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2&gt;&lt;span id=&quot;背景描述&quot;&gt;背景描述&lt;/span&gt;&lt;/h2&gt;&lt;p&gt;记录自己学习C#的学习记录&lt;/p&gt;
&lt;h2&gt;&lt;span id=&quot;阅读和学习&quot;&gt;阅读和学习&lt;/span&gt;&lt;/h2&gt;&lt;h3&gt;&lt;span id=&quot;视频&quot;&gt;视频&lt;/span&gt;&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;刘铁锰 
      
    
    </summary>
    
      <category term="C#" scheme="http://nas.lus.red/categories/C/"/>
    
    
      <category term="C#" scheme="http://nas.lus.red/tags/C/"/>
    
      <category term="笔记" scheme="http://nas.lus.red/tags/%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
</feed>
